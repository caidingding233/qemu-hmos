import router from '@ohos.router'
import common from '@ohos.app.ability.common'
import hilog from '@ohos.hilog'
import qemu from 'libqemu_hmos.so'
import vnc from '../managers/VNCNativeClient'

interface VNCNativeRouteParams { vmName?: string }

interface VMConfig {
  name: string
  accel: string
  display: string
  nographic: boolean
  diskSizeGB?: number
  memoryMB?: number
  cpuCount?: number
}

@Entry
@Component
struct VNCNativeViewer {
  @State vmName: string = ''
  @State status: string = 'å‡†å¤‡ä¸­'
  @State connected: boolean = false

  aboutToAppear() {
    const params = router.getParams() as VNCNativeRouteParams
    if (params && typeof params.vmName === 'string') this.vmName = params.vmName

    hilog.info(0x0000, 'VNC_NATIVE', `åˆå§‹åŒ–åŸç”ŸVNCé¡µé¢, VMåç§°: ${this.vmName}`)

    const vncAvailable = vnc.isAvailable()
    if (vncAvailable) {
      this.status = 'âœ… åŸç”ŸVNCå¯ç”¨ (å®éªŒæ€§)'
      hilog.info(0x0000, 'VNC_NATIVE', 'LibVNCClientåº“å¯ç”¨')

      // NAPIæ¨¡å—å·²åŠ è½½
      hilog.info(0x0000, 'VNC_NATIVE', 'NAPIæ¨¡å—å·²åŠ è½½')
    } else {
      this.status = 'âŒ åŸç”ŸVNCä¸å¯ç”¨: ç¼ºå°‘ LibVNCClient é¢„ç¼–è¯‘åº“'
      hilog.error(0x0000, 'VNC_NATIVE', 'LibVNCClientåº“ä¸å¯ç”¨ï¼Œè¯·æ£€æŸ¥åº“æ–‡ä»¶')
    }
  }

  async startAndConnect() {
    try {
      hilog.info(0x0000, 'VNC_NATIVE', 'å¼€å§‹å¯åŠ¨åŸç”ŸVNCæµç¨‹')

      // æ­¥éª¤1: æ£€æŸ¥VNCå¯ç”¨æ€§
      const vncAvailable = vnc.isAvailable()
      hilog.info(0x0000, 'VNC_NATIVE', `VNCå¯ç”¨æ€§æ£€æŸ¥: ${vncAvailable}`)
      if (!vncAvailable) {
        this.status = 'âŒ åŸç”ŸVNCä¸å¯ç”¨: LibVNCClientåº“æœªæ‰¾åˆ°'
        hilog.error(0x0000, 'VNC_NATIVE', 'LibVNCClientåº“ä¸å¯ç”¨')
        return
      }

      // æ­¥éª¤2: æ£€æŸ¥KVMæ”¯æŒ
      const kvmSupported = qemu.kvmSupported()
      hilog.info(0x0000, 'VNC_NATIVE', `KVMæ”¯æŒæ£€æŸ¥: ${kvmSupported}`)

      // æ­¥éª¤3: å‡†å¤‡VMé…ç½®
      const vmConfig: VMConfig = {
        name: 'test_vm',
        accel: kvmSupported ? 'kvm' : 'tcg',
        display: 'vnc=:1',
        nographic: false,
        diskSizeGB: 64,     // é»˜è®¤64GBç£ç›˜
        memoryMB: 4096,     // é»˜è®¤4GBå†…å­˜
        cpuCount: 4         // é»˜è®¤4æ ¸CPU
      }
      hilog.info(0x0000, 'VNC_NATIVE', `VMé…ç½®: ${JSON.stringify(vmConfig)}`)

      this.status = 'ğŸš€ å¯åŠ¨VM (æ— WebSocket)â€¦'
      hilog.info(0x0000, 'VNC_NATIVE', 'å¼€å§‹è°ƒç”¨qemu.startVm')
      
      // æ£€æŸ¥qemuå¯¹è±¡æ˜¯å¦å­˜åœ¨
      if (!qemu) {
        hilog.error(0x0000, 'VNC_NATIVE', 'qemuå¯¹è±¡ä¸ºnullæˆ–undefined')
        this.status = 'âŒ qemuå¯¹è±¡æœªåŠ è½½'
        return
      }
      
      if (!qemu.startVm) {
        hilog.error(0x0000, 'VNC_NATIVE', 'qemu.startVmæ–¹æ³•ä¸å­˜åœ¨')
        this.status = 'âŒ startVmæ–¹æ³•ä¸å­˜åœ¨'
        return
      }
      
      hilog.info(0x0000, 'VNC_NATIVE', 'qemuå¯¹è±¡å’ŒstartVmæ–¹æ³•å­˜åœ¨ï¼Œå¼€å§‹è°ƒç”¨')
      
      let ok: boolean = false
      try {
        ok = qemu.startVm(vmConfig)
        hilog.info(0x0000, 'VNC_NATIVE', `qemu.startVmè¿”å›: ${ok}`)
      } catch (error) {
        hilog.error(0x0000, 'VNC_NATIVE', `qemu.startVmå¼‚å¸¸: ${error}`)
        this.status = 'âŒ VMå¯åŠ¨å¼‚å¸¸'
        return
      }

      if (!ok) {
        this.status = 'âŒ VMå¯åŠ¨å¤±è´¥'
        hilog.error(0x0000, 'VNC_NATIVE', 'VMå¯åŠ¨å¤±è´¥ï¼Œæ£€æŸ¥æ ¸å¿ƒåº“å’Œé…ç½®')
        return
      }

      hilog.info(0x0000, 'VNC_NATIVE', 'VMå¯åŠ¨æˆåŠŸï¼Œå¼€å§‹è¿æ¥VNC')
      this.status = 'ğŸ”— è¿æ¥åŸç”ŸVNC 127.0.0.1:5901â€¦'

      // æ­¥éª¤4: ç­‰å¾…VMå¯åŠ¨å®Œæˆ
      await new Promise<void>(resolve => setTimeout(resolve, 2000))

      // æ­¥éª¤5: è¿æ¥VNC
      const connected = await vnc.connect('127.0.0.1', 5901)
      this.connected = connected

      if (connected) {
        this.status = 'âœ… å·²è¿æ¥åŸç”ŸVNC (æ¸²æŸ“å¼€å‘ä¸­)'
        hilog.info(0x0000, 'VNC_NATIVE', 'VNCè¿æ¥æˆåŠŸ')
      } else {
        this.status = 'âŒ VNCè¿æ¥å¤±è´¥ (æ£€æŸ¥VMçŠ¶æ€å’Œç½‘ç»œ)'
        hilog.error(0x0000, 'VNC_NATIVE', 'VNCè¿æ¥å¤±è´¥ï¼Œå¯èƒ½VMæœªå¯åŠ¨æˆ–ç«¯å£ä¸å¯ç”¨')
      }

    } catch (e) {
      const errorMsg = (e as Error).message
      this.status = `âŒ å¼‚å¸¸: ${errorMsg}`
      hilog.error(0x0000, 'VNC_NATIVE', `å¼‚å¸¸å‘ç”Ÿ: ${errorMsg}`)
    }
  }

  testGetFrame() {
    try {
      hilog.info(0x0000, 'VNC_NATIVE', 'æµ‹è¯•è·å–VNCå¸§')
      const frame = vnc.getFrame()
      if (frame) {
        this.status = `âœ… è·å–å¸§æˆåŠŸ: ${frame.width}x${frame.height}, ${frame.pixels?.byteLength || 0} bytes`
        hilog.info(0x0000, 'VNC_NATIVE', `å¸§ä¿¡æ¯: ${frame.width}x${frame.height}`)
      } else {
        this.status = 'âŒ è·å–å¸§å¤±è´¥: æ— å¸§æ•°æ®'
        hilog.warn(0x0000, 'VNC_NATIVE', 'è·å–å¸§å¤±è´¥')
      }
    } catch (e) {
      const errorMsg = (e as Error).message
      this.status = `âŒ è·å–å¸§å¼‚å¸¸: ${errorMsg}`
      hilog.error(0x0000, 'VNC_NATIVE', `è·å–å¸§å¼‚å¸¸: ${errorMsg}`)
    }
  }

  private goBack() { router.back() }

  build() {
    Column() {
      Row() {
        Button('è¿”å›').onClick(() => this.goBack())
        Text(this.vmName).fontSize(16).fontWeight(FontWeight.Medium).margin({ left: 8 })
      }.width('100%').padding(12)

      Text(this.status)
        .fontSize(14)
        .fontColor(this.status.includes('âŒ') ? Color.Red : this.status.includes('âœ…') ? Color.Green : Color.Grey)
        .padding(12)
        .textAlign(TextAlign.Center)

      Button('å¯åŠ¨å¹¶è¿æ¥åŸç”ŸVNC')
        .onClick(() => this.startAndConnect())
        .margin({ top: 12 })

      Button('æµ‹è¯•è·å–å¸§')
        .onClick(() => this.testGetFrame())
        .margin({ top: 8 })
        .enabled(this.connected)
    }
    .width('100%').height('100%')
  }
}
