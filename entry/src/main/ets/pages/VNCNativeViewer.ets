import router from '@ohos.router'
import common from '@ohos.app.ability.common'
import hilog from '@ohos.hilog'
import image from '@ohos.multimedia.image'
import qemu from 'qemu_hmos'

interface VncPoint {
  x: number
  y: number
}

interface QemuVncInputApi {
  vncSendPointer?: (id: number, x: number, y: number, buttonMask: number) => boolean
  vncSendKey?: (id: number, keysym: number, down: boolean) => boolean
}
interface VNCNativeRouteParams {
  vmName?: string
  vncHost?: string
  vncPort?: number
}

interface ExtendedKeyEvent {
  keyText?: string
  keyCode?: number
}

@Entry
@Component
struct VNCNativeViewer {
  // ä» AppStorage è¯»å–å‚æ•°ï¼ˆç”± VNCWindowAbility è®¾ç½®ï¼‰
  @StorageLink('vnc_vmName') vmName: string = ''
  @StorageLink('vnc_host') vncHost: string = '127.0.0.1'
  @StorageLink('vnc_port') vncPort: number = 5901
  
  @State status: string = 'å‡†å¤‡ä¸­'
  @State connected: boolean = false
  @State frameWidth: number = 640
  @State frameHeight: number = 480
  @State pixelMap: image.PixelMap | null = null
  @State hasFocus: boolean = false
  @State viewWidth: number = 0
  @State viewHeight: number = 0
  private sessionId: number = -1
  
  private renderTimer: number = -1
  private renderInFlight: boolean = false
  private buttonMask: number = 0  // VNC button mask (1=left,2=middle,4=right,8=wheel up,16=wheel down)
  private lastInputLogTs: number = 0

  private inputApi(): QemuVncInputApi {
    return qemu as QemuVncInputApi
  }

  aboutToAppear() {
    // ä¹Ÿå°è¯•ä» router å‚æ•°è¯»å–ï¼ˆå…¼å®¹ç›´æ¥é¡µé¢è·³è½¬ï¼‰
    const params = router.getParams() as VNCNativeRouteParams | undefined
    if (params) {
      if (typeof params.vmName === 'string' && params.vmName) this.vmName = params.vmName
      if (typeof params.vncHost === 'string' && params.vncHost) this.vncHost = params.vncHost
      if (typeof params.vncPort === 'number' && params.vncPort) this.vncPort = params.vncPort
    }

    hilog.info(0x0000, 'VNC_NATIVE', `åˆå§‹åŒ–åŸç”ŸVNC: VM=${this.vmName}, ${this.vncHost}:${this.vncPort}`)

    // è‡ªåŠ¨è¿æ¥ï¼ˆå¦‚æœ VM å·²ç»åœ¨è¿è¡Œï¼‰
    this.autoConnect()
  }

  aboutToDisappear() {
    this.stopRendering()
    this.disconnectNative()
  }

  async autoConnect() {
    if (!qemu.vncAvailable || !qemu.vncCreate || !qemu.vncConnect || !qemu.vncGetFrame || !qemu.vncDisconnect) {
      this.status = 'âŒ åŸç”ŸVNCä¸å¯ç”¨'
      return
    }

    this.status = `ğŸ”— è¿æ¥ ${this.vncHost}:${this.vncPort}...`
    
    // åˆ›å»º/è¿æ¥ä¼šè¯
    if (!qemu.vncAvailable()) {
      this.status = 'âŒ åŸç”ŸVNCä¸å¯ç”¨'
      return
    }
    if (this.sessionId <= 0) {
      this.sessionId = qemu.vncCreate()
    }
    const connected = qemu.vncConnect(this.sessionId, this.vncHost, this.vncPort)
    this.connected = connected

    if (connected) {
      this.status = 'âœ… å·²è¿æ¥'
      this.startRendering()
    } else {
      this.status = 'âŒ è¿æ¥å¤±è´¥ï¼Œè¯·ç¡®ä¿ VM å·²å¯åŠ¨'
    }
  }

  startRendering() {
    if (this.renderTimer >= 0) return
    
    hilog.info(0x0000, 'VNC_NATIVE', 'å¼€å§‹å¸§æ¸²æŸ“å¾ªç¯')
    
    // é™å¸§ï¼šåŸç”Ÿ VNC è·¯å¾„ä¸»è¦ç“¶é¢ˆåœ¨ PixelMap æ›´æ–°/å†…å­˜æ‹·è´ï¼Œå…ˆé»˜è®¤ 10 FPS
    this.renderTimer = setInterval(() => {
      this.renderFrame()
    }, 100)
  }

  stopRendering() {
    if (this.renderTimer >= 0) {
      clearInterval(this.renderTimer)
      this.renderTimer = -1
      hilog.info(0x0000, 'VNC_NATIVE', 'åœæ­¢å¸§æ¸²æŸ“å¾ªç¯')
    }
  }

  async renderFrame() {
    if (!this.connected) return
    if (this.renderInFlight) return
    this.renderInFlight = true

    try {
      if (!qemu.vncGetFrame || this.sessionId <= 0) return
      const frame = qemu.vncGetFrame(this.sessionId)
      if (!frame || !frame.pixels) return

      this.frameWidth = frame.width
      this.frameHeight = frame.height

      const pixels = new Uint8Array(frame.pixels)

      // åˆ›å»ºæ–° PixelMapï¼ˆå·²æ˜¾è‘—é™å‹ï¼šä»…æ–°å¸§æ‰è§¦å‘ + 10FPS + æ—  BGRA->RGBA è½¬æ¢ï¼‰
      const opts: image.InitializationOptions = {
        size: { width: frame.width, height: frame.height },
        pixelFormat: image.PixelMapFormat.RGBA_8888,
        alphaType: image.AlphaType.OPAQUE
      }

      const next = await image.createPixelMap(pixels.buffer, opts)
      if (this.pixelMap) this.pixelMap.release()
      this.pixelMap = next

    } catch (e) {
      hilog.error(0x0000, 'VNC_NATIVE', `æ¸²æŸ“å¸§å¤±è´¥: ${(e as Error).message}`)
    } finally {
      this.renderInFlight = false
    }
  }

  private goBack() {
    this.stopRendering()
    this.disconnectNative()
    router.back()
  }

  build() {
    Column() {
      // é¡¶éƒ¨çŠ¶æ€æ 
      Row() {
        Button('è¿”å›')
          .onClick(() => this.goBack())
          .height(36)
          .backgroundColor('#333')
        
        Text(this.vmName || 'VNC')
          .fontSize(16)
          .fontWeight(FontWeight.Medium)
          .fontColor('#FFF')
          .margin({ left: 12 })
        
        Blank()
        
        Text(this.status)
          .fontSize(12)
          .fontColor(this.status.includes('âŒ') ? '#FF3B30' : 
                    this.status.includes('âœ…') ? '#34C759' : '#888')
      }
      .width('100%')
      .height(48)
      .padding({ left: 12, right: 12 })
      .backgroundColor('#1A1A1A')

      // VNC æ˜¾ç¤ºåŒºåŸŸ
      Stack() {
        if (this.pixelMap) {
          Image(this.pixelMap)
            .width('100%')
            .height('100%')
            .objectFit(ImageFit.Contain)
            .focusable(true)
            // å…³é”®ï¼šç‚¹åˆ°ç”»é¢å°±è‡ªåŠ¨è·å¾—ç„¦ç‚¹ï¼Œå¦åˆ™é”®ç›˜äº‹ä»¶å¾ˆå®¹æ˜“æ”¶ä¸åˆ°
            .focusOnTouch(true)
            .onFocus(() => { this.hasFocus = true })
            .onBlur(() => { this.hasFocus = false })
            .onAreaChange((_, newArea) => {
              const w = Number(newArea.width)
              const h = Number(newArea.height)
              this.viewWidth = isNaN(w) ? 0 : w
              this.viewHeight = isNaN(h) ? 0 : h
            })
            // é”®ç›˜ï¼šéœ€è¦ç»„ä»¶è·å¾—ç„¦ç‚¹æ‰èƒ½æ”¶åˆ° KeyEventï¼ˆHarmonyOS è¾“å…¥æ¨¡å‹ï¼‰
            .onKeyEvent((event: KeyEvent) => {
              // æœ€å°å¯ç”¨æ˜ å°„ï¼šå­—æ¯æ•°å­—/å¸¸è§æ§åˆ¶é”®ï¼ˆé”®ç›˜è¾“å…¥çš„æ ¸å¿ƒå‚è€ƒï¼šHarmonyOS input overviewï¼‰
              const keysym = this.mapKeyToX11Keysym(event)
              if (keysym > 0) {
                const api = this.inputApi()
                if (api.vncSendKey && this.sessionId > 0) {
                  api.vncSendKey(this.sessionId, keysym, event.type === KeyType.Down)
                  // èŠ‚æµæ—¥å¿—ï¼šç¡®è®¤ ArkTS ç¡®å®æ”¶åˆ°äº†é”®ç›˜å¹¶ä¸‹å‘åˆ°äº† Native
                  const now = Date.now()
                  if (now - this.lastInputLogTs > 1500) {
                    this.lastInputLogTs = now
                    hilog.info(0x0000, 'VNC_NATIVE', `KeyEvent down=${event.type === KeyType.Down} keysym=0x${keysym.toString(16)}`)
                  }
                }
                return true
              }
              return false
            })
            // è§¦æ‘¸/é¼ æ ‡ï¼šæŠŠæŒ‡é’ˆäº‹ä»¶è½¬æ¢ä¸º VNC pointer
            .onTouch((ev: TouchEvent) => {
              this.handleTouch(ev)
            })
        } else {
          Column() {
            if (!this.connected) {
              Text('æœªè¿æ¥')
                .fontSize(20)
                .fontColor('#666')
              
              Button('é‡æ–°è¿æ¥')
                .onClick(() => this.autoConnect())
                .margin({ top: 16 })
                .backgroundColor('#007AFF')
            } else {
              LoadingProgress()
                .width(40)
                .height(40)
                .color('#007AFF')
              
              Text('ç­‰å¾…ç”»é¢...')
                .fontSize(14)
                .fontColor('#666')
                .margin({ top: 12 })
            }
          }
          .justifyContent(FlexAlign.Center)
        }
      }
      .width('100%')
      .layoutWeight(1)
      .backgroundColor('#000')
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#1A1A1A')
  }

  private clampPos(x: number, y: number): VncPoint {
    const xx = Math.max(0, Math.min(this.frameWidth - 1, Math.floor(x)))
    const yy = Math.max(0, Math.min(this.frameHeight - 1, Math.floor(y)))
    return { x: xx, y: yy }
  }

  // æŠŠç»„ä»¶åæ ‡æ˜ å°„åˆ°è¿œç«¯ framebuffer åæ ‡ï¼ˆImageFit.Contain ç®€åŒ–ç‰ˆï¼šæŒ‰æ¯”ä¾‹ç¼©æ”¾ï¼Œå±…ä¸­ï¼‰
  private mapPointToFrame(localX: number, localY: number, viewW: number, viewH: number): VncPoint {
    if (this.frameWidth <= 0 || this.frameHeight <= 0 || viewW <= 0 || viewH <= 0) {
      return { x: 0, y: 0 }
    }
    const scale = Math.min(viewW / this.frameWidth, viewH / this.frameHeight)
    const drawW = this.frameWidth * scale
    const drawH = this.frameHeight * scale
    const offsetX = (viewW - drawW) / 2
    const offsetY = (viewH - drawH) / 2
    const fx = (localX - offsetX) / scale
    const fy = (localY - offsetY) / scale
    return this.clampPos(fx, fy)
  }

  private handleTouch(ev: TouchEvent): void {
    if (!this.connected) return
    if (this.frameWidth <= 0 || this.frameHeight <= 0) return
    if (!ev.touches || ev.touches.length === 0) return

    // ArkUI TouchEvent: ä½¿ç”¨ç¬¬ä¸€ä¸ªè§¦ç‚¹ï¼ŒæŒ‰ press/move/release æ¨¡æ‹Ÿå·¦é”®
    const t = ev.touches[0]
    const pt = this.mapPointToFrame(t.x, t.y, this.viewWidth, this.viewHeight)

    if (ev.type === TouchType.Down) {
      this.buttonMask = 1
      const api = this.inputApi()
      if (api.vncSendPointer && this.sessionId > 0) api.vncSendPointer(this.sessionId, pt.x, pt.y, this.buttonMask)
    } else if (ev.type === TouchType.Move) {
      const api = this.inputApi()
      if (api.vncSendPointer && this.sessionId > 0) api.vncSendPointer(this.sessionId, pt.x, pt.y, this.buttonMask)
    } else if (ev.type === TouchType.Up || ev.type === TouchType.Cancel) {
      this.buttonMask = 0
      const api = this.inputApi()
      if (api.vncSendPointer && this.sessionId > 0) api.vncSendPointer(this.sessionId, pt.x, pt.y, this.buttonMask)
    }
  }

  private disconnectNative(): void {
    try {
      if (qemu.vncDisconnect && this.sessionId > 0) qemu.vncDisconnect(this.sessionId)
    } catch (_) {}
    this.sessionId = -1
    this.connected = false
  }

  // æç®€ keysym æ˜ å°„ï¼ˆX11 keysymsï¼‰
  private mapKeyToX11Keysym(event: KeyEvent): number {
    // ä»…å¤„ç†æŒ‰ä¸‹/æŠ¬èµ·
    if (event.type !== KeyType.Down && event.type !== KeyType.Up) return 0
    // ä¼˜å…ˆä½¿ç”¨ keyTextï¼ˆä¸åŒè®¾å¤‡/ç³»ç»Ÿç‰ˆæœ¬ keyCode å¯èƒ½å·®å¼‚å¾ˆå¤§ï¼‰
    const anyEvent = event as ExtendedKeyEvent
    const keyText = (typeof anyEvent.keyText === 'string') ? anyEvent.keyText : ''
    if (keyText.length === 1) {
      // å­—ç¬¦é”®ï¼šç›´æ¥ç”¨ ASCIIï¼ˆX11 keysyms å¯¹äºåŸºæœ¬ ASCII ä¸ç ç‚¹ä¸€è‡´ï¼‰
      return keyText.charCodeAt(0)
    }
    // å¸¸è§åŠŸèƒ½é”®ï¼ˆå°½é‡ç”¨ keyText åç§°å…œåº•ï¼‰
    if (keyText === 'Enter') return 0xff0d
    if (keyText === 'Backspace') return 0xff08
    if (keyText === 'Tab') return 0xff09
    if (keyText === 'Escape' || keyText === 'Esc') return 0xff1b
    if (keyText === 'ArrowLeft') return 0xff51
    if (keyText === 'ArrowUp') return 0xff52
    if (keyText === 'ArrowRight') return 0xff53
    if (keyText === 'ArrowDown') return 0xff54

    const code = (typeof anyEvent.keyCode === 'number') ? anyEvent.keyCode : 0
    // å­—æ¯ A-Z
    if (code >= 2017 && code <= 2042) { // KeyCode.KEY_A..KEY_Z (HarmonyOS å¸¸è§èŒƒå›´ï¼Œè‹¥ä¸ä¸€è‡´å¯åç»­æŒ‰å®é™…ä¿®æ­£)
      const a = 'a'.charCodeAt(0)
      return a + (code - 2017)
    }
    // æ•°å­— 0-9
    if (code >= 2007 && code <= 2016) { // KeyCode.KEY_0..KEY_9
      const zero = '0'.charCodeAt(0)
      return zero + (code - 2007)
    }

    // å¸¸ç”¨æ§åˆ¶é”®ï¼ˆkeysymsï¼‰
    // Enter=0xff0d, BackSpace=0xff08, Tab=0xff09, Escape=0xff1b, Left/Up/Right/Down=0xff51..0xff54
    if (code === 2050) return 0xff0d // Enter
    if (code === 2051) return 0xff08 // Backspace
    if (code === 2049) return 0xff09 // Tab
    if (code === 2052) return 0xff1b // Escape
    if (code === 2010) return 0xff51 // Left
    if (code === 2011) return 0xff52 // Up
    if (code === 2012) return 0xff53 // Right
    if (code === 2013) return 0xff54 // Down

    // Shift/Ctrl/Alt
    if (code === 2044) return 0xffe1 // Shift_L
    if (code === 2045) return 0xffe3 // Control_L
    if (code === 2046) return 0xffe9 // Alt_L

    return 0
  }
}
