// åŠ¨æ€å¯¼å…¥QEMUæ¨¡å—
let qemu: any = null;
import fs from '@ohos.file.fs'
import router from '@ohos.router'
import { VMCreateDialog } from '../components/VMCreateDialog';
// åŠ¨æ€å¯¼å…¥CustomDialogController
let CustomDialogController: any = null;

// å¯¼å‡ºVMCreateConfigæ¥å£ä¾›å…¶ä»–ç»„ä»¶ä½¿ç”¨
export interface VMCreateConfig {
  name: string;
  osType: string;
  isoPath: string;
  diskSize: number;
  memory: number;
  cpuCount: number;
}

interface VmMeta {
  id: string;
  name: string;
  osType: string;
  isoPath: string;
  diskSizeGB: number;
  memoryMB: number;
  cpuCount: number;
  status: 'creating' | 'preparing' | 'running' | 'stopping' | 'stopped' | 'failed';
  createdAt: number;
  // å¯é€‰ï¼šç”¨äºæ˜¾ç¤ºçš„ç³»ç»Ÿ/æ¶æ„æ ‡ç­¾
  systemCamp?: string;
  cpuCamp?: string;
}

@Entry
@Component
struct VMsPage {
  @State vms: VmMeta[] = [];
  @State showCreateDialog: boolean = false;
  @State loading: boolean = false;
  @State error: string = '';
  @State searchText: string = '';
  
  private createDialogController: CustomDialogController = new CustomDialogController({
    builder: VMCreateDialog({
      onConfirm: (config: VMCreateConfig) => this.handleCreateVM(config),
      onCancel: () => this.showCreateDialog = false
    }),
    autoCancel: true,
    alignment: DialogAlignment.Center,
    customStyle: true
  });

  aboutToAppear() {
    this.initModules();
    this.loadVms();
  }

  private async initModules() {
    try {
      // åŠ¨æ€å¯¼å…¥QEMUæ¨¡å—
      const qemuModule = await eval('import("qemu_hmos")');
      qemu = qemuModule.default;
      
      // åŠ¨æ€å¯¼å…¥CustomDialogController
      const dialogModule = await eval('import("@ohos.arkui.advanced")');
      CustomDialogController = dialogModule.CustomDialogController;
    } catch (error) {
      console.error('æ¨¡å—åŠ¨æ€å¯¼å…¥å¤±è´¥:', error);
    }
  }

  private async loadVms() {
    try {
      const savedVms = await AppStorage.Get<string>('vms');
      if (savedVms) {
        this.vms = JSON.parse(savedVms);
        // å†·å¯åŠ¨åŒæ­¥çœŸå®çŠ¶æ€ï¼Œé¿å…è¯¯æ˜¾ç¤ºä¸ºâ€œè¿è¡Œä¸­â€
        try {
          for (const vm of this.vms) {
            let live = 'stopped' as VmMeta['status']
            try { live = qemu.getVmStatus(vm.name) as VmMeta['status'] } catch (_) { live = 'stopped' }
            if (live !== 'running' && vm.status !== 'stopped') vm.status = 'stopped'
          }
          await this.saveVms()
        } catch (_) {}
      }
    } catch (e) {
      console.error('Failed to load VMs:', e);
    }
  }

  private async saveVms() {
    try {
      await AppStorage.Set<string>('vms', JSON.stringify(this.vms));
    } catch (e) {
      console.error('Failed to save VMs:', e);
    }
  }

  private async handleCreateVM(config: VMCreateConfig) {
    try {
      this.loading = true;
      this.error = '';
      
      const vmConfig = {
        name: config.name,
        isoPath: config.isoPath,
        diskSizeGB: config.diskSize,
        memoryMB: config.memory,
        cpuCount: config.cpuCount,
        accel: qemu.kvmSupported() ? 'kvm' : 'tcg',
        display: 'vnc=:1,websocket=5701',
        nographic: false
      } as const;
      
      const success = qemu.startVm(vmConfig);
      if (success) {
        const newVm: VmMeta = {
          id: Date.now().toString(),
          name: config.name,
          osType: config.osType,
          isoPath: config.isoPath,
          diskSizeGB: config.diskSize,
          memoryMB: config.memory,
          cpuCount: config.cpuCount,
          status: 'creating',
          createdAt: Date.now()
        };
        this.vms.push(newVm);
        await this.saveVms();
        this.showCreateDialog = false;
        // æˆåŠŸå¯åŠ¨åè¿›å…¥ VNC é¡µé¢
        router.pushUrl({ url: 'pages/VNCViewer', params: { vmInfo: { name: newVm.name, vncPort: 5701 } } })
          .catch((e: Error) => console.error('æ‰“å¼€VNCå¤±è´¥:', e));
        this.startVMStatusMonitoring(newVm.name);
      } else {
        this.error = 'Failed to start VM';
      }
    } catch (e) {
      console.error('Create VM failed:', e);
      this.error = `Failed to create VM: ${e}`;
    } finally {
      this.loading = false;
    }
  }

  private startVMStatusMonitoring(vmName: string) {
    // å¯åŠ¨çŠ¶æ€ç›‘æ§
    const monitorInterval = setInterval(() => {
      try {
        const status = qemu.getVmStatus(vmName);
        const vmIndex = this.vms.findIndex((vm: VmMeta) => vm.name === vmName);
        if (vmIndex !== -1) {
          this.vms[vmIndex].status = status as VmMeta['status'];
          this.saveVms();
        }
        
        // å¦‚æœVMå·²åœæ­¢ï¼Œåœæ­¢ç›‘æ§
        if (status === 'stopped' || status === 'failed') {
          clearInterval(monitorInterval);
        }
      } catch (e) {
        console.error('Status monitoring failed:', e);
        clearInterval(monitorInterval);
      }
    }, 2000);
  }

  private startVM(vm: VmMeta) {
    try {
      // è¯»å–å­˜å‚¨çš„é…ç½®ï¼Œç¼ºçœæ—¶ç»™å®‰å…¨é»˜è®¤å€¼
      const cpu = vm.cpuCount && vm.cpuCount > 0 ? vm.cpuCount : 2;
      const mem = vm.memoryMB && vm.memoryMB > 0 ? vm.memoryMB : 2048;
      const disk = vm.diskSizeGB && vm.diskSizeGB > 0 ? vm.diskSizeGB : 32;
      const success = qemu.startVm({
        name: vm.name,
        isoPath: vm.isoPath,
        diskSizeGB: disk,
        memoryMB: mem,
        cpuCount: cpu,
        accel: qemu.kvmSupported() ? 'kvm' : 'tcg',
        display: 'vnc=:1,websocket=5701',
        nographic: false
      });
      if (success) {
        vm.status = 'running';
        this.saveVms();
        // è¿›å…¥ VNC é¡µé¢
        router.pushUrl({ url: 'pages/VNCViewer', params: { vmInfo: { name: vm.name, vncPort: 5701 } } })
          .catch((e: Error) => console.error('æ‰“å¼€VNCå¤±è´¥:', e));
        this.startVMStatusMonitoring(vm.name);
      }
    } catch (e) {
      console.error('Start VM failed:', e);
      this.error = `Failed to start VM: ${e}`;
    }
  }

  private stopVM(vm: VmMeta) {
    try {
      const success = qemu.stopVm(vm.name);
      if (success) {
        vm.status = 'stopping';
        this.saveVms();
      }
    } catch (e) {
      console.error('Stop VM failed:', e);
      this.error = `Failed to stop VM: ${e}`;
    }
  }

  private async deleteVM(vm: VmMeta) {
    try {
      if (vm.status !== 'stopped' && vm.status !== 'failed') {
        this.error = 'è¯·å…ˆåœæ­¢è™šæ‹Ÿæœºå†åˆ é™¤';
        return;
      }
      this.loading = true;
      this.error = '';
      // å°è¯•åˆ é™¤ç£ç›˜æ–‡ä»¶
      const vmDir = `/data/storage/el2/base/haps/entry/files/vms/${vm.name}`
      const files = ['disk.qcow2', 'qemu.log', 'vm_config.json', 'vm_status.txt']
      for (const f of files) {
        const p = `${vmDir}/${f}`
        try { await fs.unlink(p) } catch (_) { /* å¿½ç•¥ */ }
      }
      try { await fs.rmdir(vmDir) } catch (_) {}
      // ä»å†…å­˜ä¸å­˜å‚¨ç§»é™¤
      this.vms = this.vms.filter((x: VmMeta) => x.name !== vm.name)
      await this.saveVms()
    } catch (e) {
      this.error = `åˆ é™¤å¤±è´¥: ${e}`
    } finally {
      this.loading = false;
    }
  }

  private showVMLogs(vm: VmMeta) {
    try {
      const logs = qemu.getVmLogs(vm.name);
      console.log(`VM ${vm.name} logs:`, logs);
      // è¿™é‡Œå¯ä»¥æ˜¾ç¤ºæ—¥å¿—å¯¹è¯æ¡†
    } catch (e) {
      console.error('Get VM logs failed:', e);
    }
  }

  private getStatusColor(status: VmMeta['status']): string {
    switch (status) {
      case 'running': return '#4CAF50';
      case 'creating': case 'preparing': return '#FF9800';
      case 'stopping': return '#FF5722';
      case 'stopped': return '#9E9E9E';
      case 'failed': return '#F44336';
      default: return '#9E9E9E';
    }
  }

  private getStatusText(status: VmMeta['status']): string {
    switch (status) {
      case 'running': return 'è¿è¡Œä¸­';
      case 'creating': return 'åˆ›å»ºä¸­';
      case 'preparing': return 'å‡†å¤‡ä¸­';
      case 'stopping': return 'åœæ­¢ä¸­';
      case 'stopped': return 'å·²åœæ­¢';
      case 'failed': return 'å¤±è´¥';
      default: return 'æœªçŸ¥';
    }
  }

  private getFilteredVms(): VmMeta[] {
    const keyword = this.searchText.trim().toLowerCase();
    if (!keyword) return this.vms;
    return this.vms.filter(vm => vm.name.toLowerCase().includes(keyword) || vm.osType.toLowerCase().includes(keyword));
  }

  /**
   * è·å–ç³»ç»Ÿé˜µè¥æ˜¾ç¤ºåç§°
   * ä¼˜å…ˆä½¿ç”¨çœŸå®å€¼ï¼Œæ²¡æœ‰æ—¶ä» osType æ¨å¯¼
   */
  private getSystemCamp(vm: VmMeta): string {
    // çœŸå®å€¼æ˜ å°„è¡¨
    const campDisplayMap: Record<string, string> = {
      'windows': 'Windows',
      'linux': 'Linux',
      'bsd': 'BSD',
      'harmonyos': 'HarmonyOS',
      'macos': 'macOS',
      'other': 'Other'
    };
    
    // ä¼˜å…ˆä½¿ç”¨çœŸå®å€¼
    if (vm.systemCamp) {
      return campDisplayMap[vm.systemCamp] || vm.systemCamp;
    }
    
    // æ¨å¯¼é€»è¾‘
    const os = vm.osType.toLowerCase();
    if (os.includes('win')) return 'Windows';
    if (os.includes('mac') || os.includes('darwin')) return 'macOS';
    if (os.includes('harmony') || os.includes('hmos') || os.includes('ohos')) return 'HarmonyOS';
    if (os.includes('bsd') || os.includes('freebsd')) return 'BSD';
    if (os.includes('linux') || os.includes('ubuntu') || os.includes('debian') || 
        os.includes('fedora') || os.includes('centos') || os.includes('arch') ||
        os.includes('manjaro') || os.includes('mint')) return 'Linux';
    return 'Other';
  }

  /**
   * è·å– CPU æ¶æ„æ˜¾ç¤ºåç§°
   * ä¼˜å…ˆä½¿ç”¨çœŸå®å€¼ï¼Œæ²¡æœ‰æ—¶ä»é…ç½®æ¨å¯¼
   */
  private getCpuCamp(vm: VmMeta): string {
    // çœŸå®å€¼æ˜ å°„è¡¨
    const cpuDisplayMap: Record<string, string> = {
      'aarch64': 'ARM64',
      'x86_64': 'x86_64',
      'i386': 'x86',
      'riscv64': 'RISC-V',
      'other': 'Other'
    };
    
    // ä¼˜å…ˆä½¿ç”¨çœŸå®å€¼
    if (vm.cpuCamp) {
      return cpuDisplayMap[vm.cpuCamp] || vm.cpuCamp;
    }
    
    // æ¨å¯¼é€»è¾‘ï¼šä» config.archType è·å–ï¼Œæˆ–é»˜è®¤ ARM64
    if (vm.config?.archType) {
      const arch = vm.config.archType.toLowerCase();
      if (arch.includes('aarch64') || arch.includes('arm64')) return 'ARM64';
      if (arch.includes('x86_64') || arch.includes('amd64')) return 'x86_64';
      if (arch.includes('i386') || arch.includes('x86') || arch.includes('i686')) return 'x86';
      if (arch.includes('riscv')) return 'RISC-V';
    }
    
    // é»˜è®¤ ARM64ï¼ˆé¸¿è’™è®¾å¤‡ä¸»æµæ¶æ„ï¼‰
    return 'ARM64';
  }

  build() {
    Row() {
      // å·¦ä¾§å¯¼èˆª
      Column() {
        Row() {
          Text('â‰¡')
            .fontSize(24)
            .fontWeight(FontWeight.Bold)
            .padding(12)
        }
        .margin({ bottom: 12 })
        Column() {
          Text('ğŸ‘¤')
            .fontSize(20)
            .padding({ top: 8, bottom: 4 })
          Text('è™šæ‹Ÿæœº')
            .fontSize(14)
            .fontColor('#1A73E8')
            .padding({ bottom: 12 })
          Text('âš™')
            .fontSize(18)
            .padding({ top: 8, bottom: 4 })
          Text('Apps')
            .fontSize(14)
            .fontColor('#888888')
            .padding({ bottom: 12 })
          Text('ğŸ‘¥')
            .fontSize(18)
            .padding({ top: 8, bottom: 4 })
          Text('æˆ‘çš„')
            .fontSize(14)
            .fontColor('#888888')
        }
        .alignItems(HorizontalAlign.Center)
        .layoutWeight(1)
        Text('æ·»åŠ ..')
          .fontSize(14)
          .fontColor('#1A73E8')
          .padding({ bottom: 20 })
      }
      .width(92)
      .height('100%')
      .backgroundColor('#F7F9FA')
      .justifyContent(FlexAlign.Start)
      .alignItems(HorizontalAlign.Center)

      // ä¸­é—´åˆ—è¡¨åŒº
      Column() {
        Row() {
          TextInput({ placeholder: 'æœç´¢è™šæ‹Ÿæœºçš„åå­—', text: this.searchText })
            .border({ color: '#E0E0E0', width: 1 })
            .borderRadius(24)
            .height(40)
            .padding({ left: 12, right: 12 })
            .width('70%')
            .onChange((val: string) => this.searchText = val)
          Blank()
          Button('ï¼‹ æ–°å»º')
            .backgroundColor('#1A73E8')
            .fontColor(Color.White)
            .borderRadius(20)
            .height(36)
            .padding({ left: 14, right: 14 })
            .onClick(() => this.createDialogController.open())
        }
        .width('100%')
        .padding({ top: 12, bottom: 12, left: 12, right: 12 })

        if (this.error) {
          Text(this.error)
            .fontSize(14)
            .fontColor(Color.Red)
            .padding(10)
            .backgroundColor('#FFEBEE')
            .borderRadius(8)
            .margin({ left: 12, right: 12, bottom: 8 })
        }

        Scroll() {
          Column() {
            ForEach(this.getFilteredVms(), (vm: VmMeta) => {
              Column() {
                Row() {
                  Text('â˜…')
                    .fontSize(18)
                    .fontColor('#1A73E8')
                    .margin({ right: 8 })
                  Column() {
                    Text(vm.name)
                      .fontSize(18)
                      .fontWeight(FontWeight.Medium)
                    Text(`${vm.osType} Â· ${vm.cpuCount}æ ¸ Â· ${vm.memoryMB}MB Â· ${vm.diskSizeGB}GB`)
                      .fontSize(14)
                      .fontColor('#7A7A7A')
                    Row() {
                      Text(this.getSystemCamp(vm))
                        .fontSize(12)
                        .fontColor('#1A73E8')
                        .padding({ left: 8, right: 8, top: 4, bottom: 4 })
                        .backgroundColor('#E8F1FF')
                        .borderRadius(10)
                        .margin({ right: 6 })
                      Text(this.getCpuCamp(vm))
                        .fontSize(12)
                        .fontColor('#00897B')
                        .padding({ left: 8, right: 8, top: 4, bottom: 4 })
                        .backgroundColor('#E0F2F1')
                        .borderRadius(10)
                    }
                  }
                  Blank()
                  Text(this.getStatusText(vm.status))
                    .fontSize(14)
                    .fontColor(this.getStatusColor(vm.status))
                }
                .width('100%')
                .padding({ top: 10, bottom: 10, left: 14, right: 14 })
                .onClick(() => this.startVM(vm))
              }
              .backgroundColor('#FFFFFF')
              .borderRadius(12)
              .margin({ bottom: 8, left: 8, right: 8 })
              .shadow({ radius: 6, color: '#00000010' })
            })

            if (this.getFilteredVms().length === 0) {
              Column() {
                Text('æš‚æ— è™šæ‹Ÿæœº')
                  .fontSize(16)
                  .fontWeight(FontWeight.Medium)
                  .margin({ bottom: 6 })
                Text('ç‚¹å‡»å³ä¸Šè§’ â€œï¼‹ æ–°å»ºâ€ æ¥åˆ›å»ºè™šæ‹Ÿæœº')
                  .fontSize(14)
                  .fontColor('#7A7A7A')
              }
              .width('100%')
              .height(180)
              .justifyContent(FlexAlign.Center)
              .alignItems(HorizontalAlign.Center)
              .backgroundColor('#FFFFFF')
              .borderRadius(12)
              .margin({ top: 12, left: 12, right: 12 })
              .shadow({ radius: 6, color: '#00000010' })
            }
          }
          .width('100%')
          .padding({ bottom: 12 })
        }
        .width('100%')
        .layoutWeight(1)
      }
      .width('30%')
      .height('100%')
      .backgroundColor('#F0F2F5')

      // å³ä¾§å†…å®¹å ä½
      Column() {
        if (this.error === '') {
          Text('è¯·é€‰æ‹©å·¦ä¾§è™šæ‹Ÿæœºå¼€å§‹')
            .fontSize(16)
            .fontColor('#7A7A7A')
        } else {
          Text(this.error)
            .fontSize(14)
            .fontColor(Color.Red)
            .padding(12)
            .backgroundColor('#FFEBEE')
            .borderRadius(8)
            .margin({ bottom: 12 })
        }
        Blank()
      }
      .layoutWeight(1)
      .height('100%')
      .padding(24)
      .backgroundColor('#FFFFFF')
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#ECEFF1')
  }
}
