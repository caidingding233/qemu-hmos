name: Build QEMU for HarmonyOS (Robust)

on:
  workflow_dispatch:
  push:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-24.04
    
    steps:
    - name: 下下来
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: 然后安装最小的依赖 (仅主机工具)
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential curl wget unzip python3 \
                                pkg-config git ca-certificates \
                                libglib2.0-dev libpixman-1-dev \
                                libzstd-dev zstd

    - name: 安装 arm64 架构的开发库
      run: |
        # 启用多架构支持
        sudo dpkg --add-architecture arm64
        
        # 添加 arm64 包源（只使用 ports.ubuntu.com，因为 security.ubuntu.com 不支持 ARM64）
        echo "deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports noble main restricted universe multiverse" | sudo tee /etc/apt/sources.list.d/arm64.list
        echo "deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports noble-updates main restricted universe multiverse" | sudo tee -a /etc/apt/sources.list.d/arm64.list
        echo "deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports noble-security main restricted universe multiverse" | sudo tee -a /etc/apt/sources.list.d/arm64.list
        
        # 配置多架构支持：AMD64 用于主机工具，ARM64 用于目标包
        # 备份原始 sources.list
        sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak
        
        # 重写 sources.list，支持多架构
        sudo bash -c "echo '# 默认源 - 支持 AMD64 和 ARM64' > /etc/apt/sources.list"
        sudo bash -c "echo 'deb http://azure.archive.ubuntu.com/ubuntu/ noble main restricted universe multiverse' >> /etc/apt/sources.list"
        sudo bash -c "echo 'deb http://azure.archive.ubuntu.com/ubuntu/ noble-updates main restricted universe multiverse' >> /etc/apt/sources.list"
        sudo bash -c "echo 'deb http://azure.archive.ubuntu.com/ubuntu/ noble-backports main restricted universe multiverse' >> /etc/apt/sources.list"
        sudo bash -c "echo 'deb http://azure.archive.ubuntu.com/ubuntu/ noble-security main restricted universe multiverse' >> /etc/apt/sources.list"
        
        # 验证修改结果
        echo "=== 修改后的 sources.list ==="
        cat /etc/apt/sources.list
        
        # 更新包列表
        sudo apt-get update
        
        # 先检查可用的包
        echo "=== 检查可用的 arm64 包 ==="
        apt-cache search --names-only "libglib2.0-dev" | grep arm64 || true
        apt-cache search --names-only "libpixman-1-dev" | grep arm64 || true
        
        # 尝试安装，如果失败则使用替代方案
        if ! sudo apt-get install -y libglib2.0-dev:arm64 libpixman-1-dev:arm64 zlib1g-dev:arm64 libc6-dev:arm64 libffi-dev:arm64; then
          echo "::warning::arm64 包安装失败，将使用静态链接方案"
          # 设置环境变量指示使用静态链接
          echo "USE_STATIC_LINKING=true" >> $GITHUB_ENV
        else
          echo "::info::arm64 包安装成功"
          echo "USE_STATIC_LINKING=false" >> $GITHUB_ENV
        fi

    - name: 再呢就是设置 Python (用于 Meson/Ninja)
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        cache: 'pip'

    - name: 下一步下 Meson>=1.6 & Ninja, 并锁定 PATH
      run: |
        python -m pip install --upgrade --user 'meson>=1.6.0' 'ninja>=1.11'
        echo "$HOME/.local/bin" >> $GITHUB_PATH
        MESON_BIN="$(python -c 'import shutil;print(shutil.which("meson"))')"
        NINJA_BIN="$(python -c 'import shutil;print(shutil.which("ninja"))')"
        echo "MESON=$MESON_BIN" >> $GITHUB_ENV
        echo "NINJA=$NINJA_BIN" >> $GITHUB_ENV
        echo "Using MESON=$MESON_BIN"
        echo "Using NINJA=$NINJA_BIN"
        "$MESON_BIN" --version
        "$NINJA_BIN" --version
        # Hard guard: fail if < 1.5
        if ! "$MESON_BIN" --version | awk '{split($1,a,"."); exit !((a[1] > 1) || (a[1]==1 && a[2]>=5));}'; then
          echo "::error::Meson too old"; exit 1; fi
        type -a meson || true

    - name: 再就是下鸿蒙的 NDK (linux版)
      run: |
        set -e
        urls=(
          "https://repo.huaweicloud.com/openharmony/os/5.1.0-Release/ohos-sdk-windows_linux-public.tar.gz"
          "https://repo.huaweicloud.com/openharmony/os/5.0.0-Release/ohos-sdk-windows_linux-public.tar.gz"
          "https://repo.huaweicloud.com/openharmony/os/4.1.0-Release/ohos-sdk-windows_linux-public.tar.gz"
        )
        for u in "${urls[@]}"; do
          echo "Try $u"
          if curl -L --retry 3 -o ohos-sdk.tar.gz "$u"; then
            break
          fi
        done
        tar -xzf ohos-sdk.tar.gz
        rm -f ohos-sdk.tar.gz
        # 仅保留 linux 目录
        rm -rf ohos-sdk/ohos ohos-sdk/windows || true
        ls -la ohos-sdk/linux

    - name: 现在来找找到 native 工具链 (clang & sysroot)
      id: ndk
      run: |
        set -e
        cd ohos-sdk/linux
        # 找 native 包
        zip=$(find . -type f -name "*native*linux*x64*.zip" -o -name "*native*linux*.zip" | head -1)
        [ -n "$zip" ] || { echo "No native SDK zip found"; exit 1; }
        unzip -q "$zip"
        rm -f "$zip"

        native_dir=$(find . -maxdepth 1 -type d -name "native-*" -o -name "*native*" | head -1)
        [ -n "$native_dir" ] || { echo "No native dir"; exit 1; }

        llvm_bin="$PWD/$native_dir/llvm/bin"
        sysroot="$PWD/$native_dir/sysroot"

        # 优先使用带 triple 的编译器
        if [ -x "$llvm_bin/aarch64-unknown-linux-ohos-clang" ]; then
          cc="$llvm_bin/aarch64-unknown-linux-ohos-clang"
          cxx="$llvm_bin/aarch64-unknown-linux-ohos-clang++"
        else
          cc="$llvm_bin/clang"
          cxx="$llvm_bin/clang++"
        fi

        echo "OHOS_NDK_HOME=$PWD/$native_dir" >> $GITHUB_ENV
        echo "SYSROOT=$sysroot" >> $GITHUB_ENV
        echo "CC=$cc" >> $GITHUB_ENV
        echo "CXX=$cxx" >> $GITHUB_ENV
        echo "AR=$llvm_bin/llvm-ar" >> $GITHUB_ENV
        echo "RANLIB=$llvm_bin/llvm-ranlib" >> $GITHUB_ENV
        echo "STRIP=$llvm_bin/llvm-strip" >> $GITHUB_ENV

        echo "ndk_dir=$native_dir" >> $GITHUB_OUTPUT

    - name: 在准备 Meson 要用的交叉编译文件(aarch64-ohos.ini)
      run: |
        set -e
        mkdir -p cross
        cat > cross/aarch64-ohos.ini <<EOF
        [binaries]
        c = '${CC}'
        cpp = '${CXX}'
        ar = '${AR}'
        strip = '${STRIP}'
        pkgconfig = 'pkg-config'
        ld = '${CC}'

        [host_machine]
        system = 'linux'
        cpu_family = 'aarch64'
        cpu = 'armv8'
        endian = 'little'

        [built-in options]
        c_args = ['--sysroot=${SYSROOT}','-fPIC','-O2','-pipe','-fvisibility=hidden','-nostdinc','-I${SYSROOT}/usr/include','-I/usr/include/glib-2.0','-I/usr/lib/x86_64-linux-gnu/glib-2.0/include']
        cpp_args = ['--sysroot=${SYSROOT}','-fPIC','-O2','-pipe','-fvisibility=hidden','-nostdinc','-I${SYSROOT}/usr/include','-I/usr/include/glib-2.0','-I/usr/lib/x86_64-linux-gnu/glib-2.0/include']
        c_link_args = ['--sysroot=${SYSROOT}']
        cpp_link_args = ['--sysroot=${SYSROOT}']
        EOF
        echo "Cross file written to: $GITHUB_WORKSPACE/cross/aarch64-ohos.ini"
        ls -la cross
        echo "Preview:"
        sed -n '1,80p' cross/aarch64-ohos.ini

    - name: 再就是提供子项目 (pcre2/libffi 通过 wraps包，glib/pixman用系统的)
      run: |
        set -e
        cd third_party/qemu
        mkdir -p subprojects
        "$MESON" wrap install pcre2
        "$MESON" wrap install libffi
        ls -la subprojects

    - name: 最后就是开始构建QEMU(ARM + X86 多目标构建)
      run: |
        set -e
        echo "MESON is $MESON"
        echo "NINJA is $NINJA"
        if [ ! -x "$MESON" ]; then
          echo "::error::MESON not found or not executable at $MESON"
          which meson || true
          ls -la "$HOME/.local/bin" || true
          exit 1
        fi
        # Export pkg-config：根据 aarch64 库安装情况配置路径
        export PKG_CONFIG_DIR=
        if [ "$USE_STATIC_LINKING" = "true" ]; then
          echo "::info::使用静态链接模式，避免架构冲突"
          export PKG_CONFIG_PATH="${SYSROOT}/usr/lib/pkgconfig:${SYSROOT}/usr/share/pkgconfig:${SYSROOT}/lib/pkgconfig"
          export LIBRARY_PATH="${SYSROOT}/usr/lib"
          export LD_LIBRARY_PATH="${SYSROOT}/usr/lib"
        else
          echo "::info::使用 arm64 库模式"
          export PKG_CONFIG_PATH="/usr/lib/aarch64-linux-gnu/pkgconfig:${SYSROOT}/usr/lib/pkgconfig:${SYSROOT}/usr/share/pkgconfig:${SYSROOT}/lib/pkgconfig"
          export LIBRARY_PATH="/usr/lib/aarch64-linux-gnu:${SYSROOT}/usr/lib"
          export LD_LIBRARY_PATH="/usr/lib/aarch64-linux-gnu:${SYSROOT}/usr/lib"
        fi
        echo "PKG_CONFIG_PATH=${PKG_CONFIG_PATH}"
        echo "LIBRARY_PATH=${LIBRARY_PATH}"
        
        # 验证 arm64 库安装
        echo "=== 验证 arm64 库架构 ==="
        if [ -f "/usr/lib/aarch64-linux-gnu/libglib-2.0.so" ]; then
          file /usr/lib/aarch64-linux-gnu/libglib-2.0.so
        else
          echo "::warning::arm64 GLib library not found"
        fi
        if [ -f "/usr/lib/aarch64-linux-gnu/libpixman-1.so" ]; then
          file /usr/lib/aarch64-linux-gnu/libpixman-1.so
        else
          echo "::warning::arm64 Pixman library not found"
        fi
        
        CROSS_FILE="$GITHUB_WORKSPACE/cross/aarch64-ohos.ini"
        echo "Using CROSS_FILE=$CROSS_FILE"
        if [ ! -f "$CROSS_FILE" ]; then
          echo "::error::Cross file not found at $CROSS_FILE"
          ls -la "$GITHUB_WORKSPACE" || true
          ls -la "$GITHUB_WORKSPACE/cross" || true
          exit 1
        fi
        
        # 根据构建模式调整 cross 文件
        if [ "$USE_STATIC_LINKING" = "true" ]; then
          echo "::info::使用静态链接 cross 配置"
          # 创建静态链接专用的 cross 文件
          echo "[binaries]" > "$CROSS_FILE"
          echo "c = 'aarch64-unknown-linux-ohos-clang'" >> "$CROSS_FILE"
          echo "cpp = 'aarch64-unknown-linux-ohos-clang++'" >> "$CROSS_FILE"
          echo "ar = 'llvm-ar'" >> "$CROSS_FILE"
          echo "ld = 'ld.lld'" >> "$CROSS_FILE"
          echo "strip = 'llvm-strip'" >> "$CROSS_FILE"
          echo "pkgconfig = 'pkg-config'" >> "$CROSS_FILE"
          echo "" >> "$CROSS_FILE"
          echo "[host_machine]" >> "$CROSS_FILE"
          echo "system = 'linux'" >> "$CROSS_FILE"
          echo "cpu_family = 'aarch64'" >> "$CROSS_FILE"
          echo "cpu = 'aarch64'" >> "$CROSS_FILE"
          echo "endian = 'little'" >> "$CROSS_FILE"
          echo "" >> "$CROSS_FILE"
          echo "[properties]" >> "$CROSS_FILE"
          echo "needs_exe_wrapper = true" >> "$CROSS_FILE"
          echo "" >> "$CROSS_FILE"
          echo "[built-in options]" >> "$CROSS_FILE"
          echo "c_args = ['--sysroot=\${SYSROOT}','-fPIC','-O2','-pipe','-fvisibility=hidden','-nostdinc','-I\${SYSROOT}/usr/include']" >> "$CROSS_FILE"
          echo "cpp_args = ['--sysroot=\${SYSROOT}','-fPIC','-O2','-pipe','-fvisibility=hidden','-nostdinc','-I\${SYSROOT}/usr/include']" >> "$CROSS_FILE"
          echo "c_link_args = ['--sysroot=\${SYSROOT}']" >> "$CROSS_FILE"
          echo "cpp_link_args = ['--sysroot=\${SYSROOT}']" >> "$CROSS_FILE"
          echo "" >> "$CROSS_FILE"
          echo "[paths]" >> "$CROSS_FILE"
          echo "sys_root = '\${SYSROOT}'" >> "$CROSS_FILE"
        else
          echo "::info::使用 arm64 库 cross 配置"
          # 使用原有的 cross 文件（包含 arm64 库路径）
        fi
        cd third_party/qemu
        rm -rf build && mkdir build && cd build

        # Detect whether this QEMU fork exposes 'target_list' in meson_options.txt
        TLIST_ARG=""
        if [ -f ../meson_options.txt ] && grep -q "option('target_list'" ../meson_options.txt; then
          TLIST_ARG="-Dtarget_list=aarch64-softmmu,x86_64-softmmu,i386-softmmu"
          echo "Detected target_list option; will pass: ${TLIST_ARG}"
        else
          echo "This QEMU does not define 'target_list'; building project defaults."
          # Try to build with single target first to see if it works
          TLIST_ARG="--target-list=aarch64-softmmu"
        fi

            # 鸿蒙版 UTM 多目标构建：使用 configure 脚本（它会调用 meson）
            if [ "$USE_STATIC_LINKING" = "true" ]; then
              echo "::info::配置静态链接构建"
              ../configure \
                --cross-prefix="" \
                --cc="${CC}" \
                --cxx="${CXX}" \
                --host-cc="/usr/bin/cc" \
                $TLIST_ARG \
                --extra-cflags="--sysroot=${SYSROOT} -fPIC -march=armv8-a -Wno-error=typedef-redefinition -Wno-error=macro-redefined" \
                --extra-ldflags="--sysroot=${SYSROOT}" \
                --static \
                --disable-gnutls \
                --disable-gtk --disable-sdl --disable-curses --disable-vte \
                --disable-brlapi --disable-spice --disable-libssh \
                --disable-nettle --disable-gcrypt \
                --enable-tcg \
                --disable-slirp \
                --enable-vnc \
                --disable-plugins \
                --disable-pixman \
                --disable-system \
                -Dwrap_mode=forcefallback \
                -Ddefault_library=static \
                -Db_staticpic=true \
                -Dvhost_user=disabled \
                -Dvhost_user_blk_server=disabled \
                -Dlibvduse=disabled \
                -Dvduse_blk_export=disabled \
                -Dvhost_net=disabled \
                -Dvhost_kernel=disabled \
                -Dkeyring=disabled \
                -Dzstd=disabled \
                -Dguest_agent=disabled \
                -Dtools=disabled
            else
              echo "::info::配置 arm64 库链接构建"
              ../configure \
                --cross-prefix="" \
                --cc="${CC}" \
                --cxx="${CXX}" \
                --host-cc="/usr/bin/cc" \
                $TLIST_ARG \
                --extra-cflags="--sysroot=${SYSROOT} -fPIC -march=armv8-a -Wno-error=typedef-redefinition -Wno-error=macro-redefined -I/usr/include/aarch64-linux-gnu" \
                --extra-ldflags="--sysroot=${SYSROOT} -L/usr/lib/aarch64-linux-gnu" \
                --disable-gnutls \
                --disable-gtk --disable-sdl --disable-curses --disable-vte \
                --disable-brlapi --disable-spice --disable-libssh \
                --disable-nettle --disable-gcrypt \
                --enable-tcg \
                --disable-slirp \
                --enable-vnc \
                --disable-plugins \
                -Dwrap_mode=forcefallback \
                -Ddefault_library=static \
                -Db_staticpic=true \
                -Dvhost_user=disabled \
                -Dvhost_user_blk_server=disabled \
                -Dlibvduse=disabled \
                -Dvduse_blk_export=disabled \
                -Dvhost_net=disabled \
                -Dvhost_kernel=disabled \
                -Dkeyring=disabled \
                -Dzstd=disabled \
                -Dguest_agent=disabled \
                -Dtools=disabled
            fi

        echo "=== 网络功能说明 ==="
        echo "✅ 已禁用 slirp 避免架构冲突"
        echo "✅ 已禁用 plugins 避免 GLib 架构冲突"
        echo "✅ 网络功能将通过 user 模式提供（hostfwd 端口转发）"
        echo "✅ 支持 HTTP(S)、DNS、RDP、SSH 等基础网络功能"
        echo "✅ M365/OneDrive 登录不受影响"

        # 构建所有目标
        "$NINJA" -v -j"$(nproc)"

        echo "=== 构建产物检查 ==="
        for bin in qemu-system-aarch64 qemu-system-x86_64 qemu-system-i386; do
          if [ -f "$bin" ]; then
            ls -lh "$bin"
            file "$bin" || true
          else
            echo "Note: $bin not built in this configuration."
          fi
        done
        
        # 产物：优先使用 aarch64，如不存在则挑选已生成的第一个系统仿真器
        OUT_SO=""
        for cand in qemu-system-aarch64 qemu-system-x86_64 qemu-system-i386; do
          if [ -f "$cand" ]; then OUT_SO="$cand"; break; fi
        done
        if [ -n "$OUT_SO" ]; then
          cp "$OUT_SO" libqemu_full.so
          echo "=== 鸿蒙版 UTM 产物 ==="
          ls -lh libqemu_full.so
          file libqemu_full.so || true
        else
          echo "::warning::No qemu-system-* binaries were produced; please inspect meson-logs/meson-log.txt."
        fi

    - name: OK啊上传产物
      uses: actions/upload-artifact@v4
      with:
        name: qemu-hmos-utm-multiarch
        path: |
          third_party/qemu/build/qemu-system-aarch64
          third_party/qemu/build/qemu-system-x86_64
          third_party/qemu/build/qemu-system-i386
          third_party/qemu/build/libqemu_full.so
        if-no-files-found: ignore