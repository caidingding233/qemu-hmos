name: Build QEMU with Huawei's toolchain (Robust)

on:
  workflow_dispatch:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-24.04
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Update submodules (including qemu-code)
      run: |
        echo "=== Updating submodules ==="
        git submodule update --init --recursive

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential cmake curl wget unzip python3 \
                              libglib2.0-dev libpixman-1-dev libssl-dev \
                              libcurl4-openssl-dev libssh-dev libgnutls28-dev \
                              libsasl2-dev libpam0g-dev libbz2-dev libzstd-dev \
                              libpcre2-dev pkg-config meson tree \
                              binutils-aarch64-linux-gnu gcc-aarch64-linux-gnu \
                              libc6-dev libc6-dev-arm64-cross \
                              libgnutls-openssl-dev  # 添加gnutls openssl支持

    - name: Download and setup SDK
      run: |
        echo "=== Downloading SDK ==="
        # Try multiple SDK URLs
        SDK_URLS=(
          "https://repo.huaweicloud.com/openharmony/os/5.1.0-Release/ohos-sdk-windows_linux-public.tar.gz"
          "https://repo.huaweicloud.com/openharmony/os/5.0.0-Release/ohos-sdk-windows_linux-public.tar.gz"
          "https://repo.huaweicloud.com/openharmony/os/4.1.0-Release/ohos-sdk-windows_linux-public.tar.gz"
        )
        
        SDK_DOWNLOADED=false
        for url in "${SDK_URLS[@]}"; do
          echo "Trying SDK URL: $url"
          if curl -L -o ohos-sdk.tar.gz "$url"; then
            echo "✅ SDK downloaded successfully from: $url"
            SDK_DOWNLOADED=true
            break
          else
            echo "❌ Failed to download from: $url"
          fi
        done
        
        if [ "$SDK_DOWNLOADED" = false ]; then
          echo "❌ All SDK download attempts failed"
          exit 1
        fi
        
        echo "=== Extracting SDK ==="
        tar -xzf ohos-sdk.tar.gz
        rm ohos-sdk.tar.gz
        rm -rf ohos-sdk/{ohos,windows}
        
        echo "=== Analyzing SDK structure ==="
        echo "Root SDK structure:"
        ls -la ohos-sdk/
        
        echo ""
        echo "Linux SDK structure:"
        ls -la ohos-sdk/linux/
        
        echo ""
        echo "All files in linux directory:"
        find ohos-sdk/linux -type f | head -20

    - name: Find and extract native SDK
      run: |
        echo "=== Finding native SDK ==="
        cd ohos-sdk/linux
        
        # Look for any zip files that might contain native tools
        echo "Looking for zip files:"
        find . -name "*.zip" -type f
        
        # Try different patterns for native SDK
        NATIVE_PATTERNS=(
          "native-linux-x64-*.zip"
          "native-*.zip"
          "*native*.zip"
          "*-native-*.zip"
        )
        
        NATIVE_ZIP=""
        for pattern in "${NATIVE_PATTERNS[@]}"; do
          echo "Searching for pattern: $pattern"
          found=$(find . -name "$pattern" -type f | head -1)
          if [ -n "$found" ]; then
            NATIVE_ZIP="$found"
            echo "✅ Found native SDK: $NATIVE_ZIP"
            break
          fi
        done
        
        if [ -z "$NATIVE_ZIP" ]; then
          echo "❌ No native SDK zip found"
          echo "Available files:"
          find . -type f | head -20
          echo ""
          echo "Trying to find any clang compiler directly:"
          find . -name "*clang*" -type f | head -10
          exit 1
        fi
        
        echo "=== Extracting native SDK ==="
        echo "Extracting: $NATIVE_ZIP"
        unzip -q "$NATIVE_ZIP"
        rm "$NATIVE_ZIP"
        
        # 先设置SYSROOT变量，因为后面需要用到
        echo "=== 设置SYSROOT变量 ==="
        # 查找native目录
        NATIVE_DIR=""
        for pattern in "native-linux-x64-*" "native-*" "*native*"; do
          found=$(find . -name "$pattern" -type d | head -1)
          if [ -n "$found" ]; then
            NATIVE_DIR="$found"
            echo "✅ Found with pattern '$pattern': $NATIVE_DIR"
            break
          fi
        done
        
        if [ -z "$NATIVE_DIR" ]; then
          NATIVE_DIR=$(find . -type d -name 'native' | head -1)
          if [ -n "$NATIVE_DIR" ]; then
            echo "✅ Found generic native directory: $NATIVE_DIR"
          fi
        fi
        
        if [ -z "$NATIVE_DIR" ]; then
          echo "❌ No native directory found after extraction"
          exit 1
        fi
        
        export SYSROOT="$(pwd)/$NATIVE_DIR/sysroot"
        echo "SYSROOT set to: $SYSROOT"

        # 验证华为 SDK 的 musl 头文件系统
        echo "=== 验证华为 SDK musl 头文件系统 ==="
        
        echo "检查华为 SDK 的 musl 头文件结构..."
        echo "SYSROOT: $SYSROOT"
        
        # 检查关键文件是否存在
        echo "检查关键头文件:"
        [ -f "$SYSROOT/usr/include/sys/socket.h" ] && echo "✓ sys/socket.h 存在" || echo "✗ sys/socket.h 缺失"
        [ -f "$SYSROOT/usr/include/aarch64-linux-ohos/bits/alltypes.h" ] && echo "✓ alltypes.h 存在" || echo "✗ alltypes.h 缺失"
        [ -f "$SYSROOT/usr/include/aarch64-linux-ohos/bits/socket.h" ] && echo "✓ bits/socket.h 存在" || echo "✗ bits/socket.h 缺失"
        
        # 检查类型定义
        echo "检查类型定义:"
        if grep -q "socklen_t" "$SYSROOT/usr/include/aarch64-linux-ohos/bits/alltypes.h" 2>/dev/null; then
          echo "✓ socklen_t 已定义"
        else
          echo "✗ socklen_t 未定义"
        fi
        
        if grep -q "sa_family_t" "$SYSROOT/usr/include/aarch64-linux-ohos/bits/alltypes.h" 2>/dev/null; then
          echo "✓ sa_family_t 已定义"
        else
          echo "✗ sa_family_t 未定义"
        fi
        
        echo "华为 SDK 使用 musl libc，头文件结构正确，无需额外修复"
        
        echo "=== Analyzing extracted content ==="
        echo "Contents after extraction:"
        ls -la
        
        echo "✅ Final native directory: $NATIVE_DIR"

        echo "=== Analyzing native directory ==="
        echo "Contents of $NATIVE_DIR:"
        ls -la "$NATIVE_DIR"

        # Persist native directory path for later steps
        echo "NATIVE_DIR=$NATIVE_DIR" >> $GITHUB_ENV
        
        echo ""
        echo "Looking for llvm directory:"
        find "$NATIVE_DIR" -name "llvm" -type d
        
        echo ""
        echo "Looking for build-tools directory:"
        find "$NATIVE_DIR" -name "build-tools" -type d
        
        echo ""
        echo "Looking for any clang compiler:"
        find "$NATIVE_DIR" -name "*clang*" -type f

    - name: Verify sysroot headers
      run: |
        echo "=== 验证sysroot头文件状态 ==="
        echo "SYSROOT: $SYSROOT"
        echo "Checking sysroot structure:"
        ls -la "$SYSROOT" || echo "Cannot list SYSROOT"
        echo ""
        echo "Checking usr/include:"
        ls -la "$SYSROOT/usr/include" 2>/dev/null || echo "Cannot list usr/include"
        echo ""
        echo "Checking for key header files:"
        [ -f "$SYSROOT/usr/include/limits.h" ] && echo "✓ limits.h exists" || echo "✗ limits.h missing"
        [ -d "$SYSROOT/usr/include/bits" ] && echo "✓ bits directory exists" || echo "✗ bits directory missing"
        [ -f "$SYSROOT/usr/include/bits/limits.h" ] && echo "✓ bits/limits.h exists" || echo "✗ bits/limits.h missing"

    - name: Setup environment and test
      run: |
        echo "=== Setting up environment ==="
        cd ohos-sdk/linux
        
        # Set up paths based on what we found
        export OHOS_NDK_HOME="$(pwd)/$NATIVE_DIR"
        export SYSROOT="$(pwd)/$NATIVE_DIR/sysroot"
        
        # Try to find clang compiler
        CLANG_CANDIDATES=(
          "$(pwd)/$NATIVE_DIR/llvm/bin/aarch64-unknown-linux-ohos-clang"
          "$(pwd)/$NATIVE_DIR/llvm/bin/clang"
          "$(pwd)/$NATIVE_DIR/bin/aarch64-unknown-linux-ohos-clang"
          "$(pwd)/$NATIVE_DIR/bin/clang"
        )
        
        CC=""
        for candidate in "${CLANG_CANDIDATES[@]}"; do
          if [ -f "$candidate" ]; then
            CC="$candidate"
            echo "✅ Found CC: $CC"
            break
          fi
        done
        
        if [ -z "$CC" ]; then
          echo "❌ No clang compiler found"
          echo "Available files in native directory:"
          find "$NATIVE_DIR" -type f | head -20
          LLVM_BIN_DIR="$(pwd)/$NATIVE_DIR/llvm/bin"
          if [ -d "$LLVM_BIN_DIR" ]; then
            echo ""
            echo "Attempting fallback discovery in $LLVM_BIN_DIR"
            CLANG_AUTO=$(find "$LLVM_BIN_DIR" -maxdepth 1 -name "clang*" -type f | head -1)
            if [ -n "$CLANG_AUTO" ]; then
              echo "✅ Auto-detected CC candidate: $CLANG_AUTO"
              CC="$CLANG_AUTO"
            fi
          fi
        fi

        if [ -z "$CC" ]; then
          echo "❌ Still no clang compiler found"
          exit 1
        fi
        
        # Try to find C++ compiler
        CXX_CANDIDATES=(
          "$(pwd)/$NATIVE_DIR/llvm/bin/aarch64-unknown-linux-ohos-clang++"
          "$(pwd)/$NATIVE_DIR/llvm/bin/clang++"
          "$(pwd)/$NATIVE_DIR/bin/aarch64-unknown-linux-ohos-clang++"
          "$(pwd)/$NATIVE_DIR/bin/clang++"
        )
        
        CXX=""
        for candidate in "${CXX_CANDIDATES[@]}"; do
          if [ -f "$candidate" ]; then
            CXX="$candidate"
            echo "✅ Found CXX: $CXX"
            break
          fi
        done
        
        if [ -z "$CXX" ]; then
          echo "⚠️ No C++ compiler found, using CC for CXX"
          LLVM_BIN_DIR="$(pwd)/$NATIVE_DIR/llvm/bin"
          if [ -d "$LLVM_BIN_DIR" ]; then
            CLANGXX_AUTO=$(find "$LLVM_BIN_DIR" -maxdepth 1 -name "clang++*" -type f | head -1)
            if [ -n "$CLANGXX_AUTO" ]; then
              echo "✅ Auto-detected clang++ candidate: $CLANGXX_AUTO"
              CXX="$CLANGXX_AUTO"
            fi
          fi
        fi

        if [ -z "$CXX" ]; then
          echo "⚠️ Falling back to CC for CXX"
          CXX="$CC"
        fi
        
        # Try to find CMake
        CMAKE_CANDIDATES=(
          "$(pwd)/$NATIVE_DIR/build-tools/cmake/bin/cmake"
          "$(pwd)/$NATIVE_DIR/cmake/bin/cmake"
          "$(pwd)/$NATIVE_DIR/bin/cmake"
          "/usr/bin/cmake"
        )
        
        CMAKE=""
        for candidate in "${CMAKE_CANDIDATES[@]}"; do
          if [ -f "$candidate" ]; then
            CMAKE="$candidate"
            echo "✅ Found CMake: $CMAKE"
            break
          fi
        done
        
        if [ -z "$CMAKE" ]; then
          echo "❌ No CMake found"
          exit 1
        fi
        
        echo "=== Final environment ==="
        echo "OHOS_NDK_HOME: $OHOS_NDK_HOME"
        echo "SYSROOT: $SYSROOT"
        echo "CC: $CC"
        echo "CXX: $CXX"
        echo "CMAKE: $CMAKE"
        
        echo ""
        echo "=== Testing tools ==="
        echo "Testing CC:"
        file "$CC"
        "$CC" --version 2>&1 | head -3 || echo "CC version check failed"
        
        echo ""
        echo "Testing CMake:"
        "$CMAKE" --version | head -3 || echo "CMake version check failed"
        
        # Save environment for next steps
        echo "OHOS_NDK_HOME=$OHOS_NDK_HOME" >> $GITHUB_ENV
        echo "SYSROOT=$SYSROOT" >> $GITHUB_ENV
        echo "CC=$CC" >> $GITHUB_ENV
        echo "CXX=$CXX" >> $GITHUB_ENV
        echo "CMAKE=$CMAKE" >> $GITHUB_ENV

    - name: Build QEMU
      run: |
        echo "=== Restoring environment variables ==="
        # Restore environment variables from previous step
        export OHOS_NDK_HOME="$OHOS_NDK_HOME"
        export SYSROOT="$SYSROOT"
        export CC="$CC"
        export CXX="$CXX"
        export CMAKE="$CMAKE"

        echo "=== Building QEMU ==="
        cd third_party/qemu

        mkdir -p build
        cd build

        echo "Environment check:"
        echo "CC: $CC"
        echo "CXX: $CXX"
        echo "SYSROOT: $SYSROOT"
        
        echo ""
        echo "=== Testing posix_memalign availability ==="
        # 测试 posix_memalign 是否可用（跳过执行测试，因为交叉编译）
        cat > test_memalign.c << 'EOF'
        #include <stdlib.h>
        #include <stdio.h>
        int main() {
            void *ptr;
            int ret = posix_memalign(&ptr, 16, 1024);
            if (ret == 0) {
                printf("posix_memalign available\n");
                free(ptr);
                return 0;
            } else {
                printf("posix_memalign failed: %d\n", ret);
                return 1;
            }
        }
        EOF
        
        # 只测试编译，不执行（因为交叉编译）
        if "$CC" -o test_memalign test_memalign.c 2>/dev/null; then
            echo "✅ posix_memalign compiles successfully"
            export POSIX_MEMALIGN_AVAILABLE=1
        else
            echo "⚠️ posix_memalign compilation failed, will use fallback"
            export POSIX_MEMALIGN_AVAILABLE=0
        fi
        rm -f test_memalign.c test_memalign
        
        echo ""
        echo "=== Testing compiler availability ==="
        # 测试编译器是否真的可用
        echo "Testing CC: $CC"
        if [ -f "$CC" ]; then
            echo "✅ CC exists: $CC"
            file "$CC"
            "$CC" --version 2>&1 | head -3 || echo "CC version check failed"
        else
            echo "❌ CC not found: $CC"
            echo "Available files in llvm/bin:"
            ls -la "$(dirname "$CC")" || echo "Cannot list llvm/bin"
            exit 1
        fi
        
        echo ""
        echo "Testing CXX: $CXX"
        if [ -f "$CXX" ]; then
            echo "✅ CXX exists: $CXX"
            file "$CXX"
            "$CXX" --version 2>&1 | head -3 || echo "CXX version check failed"
        else
            echo "❌ CXX not found: $CXX"
            exit 1
        fi
        
        echo ""
        echo "=== Running Configure ==="
            # 使用华为的编译器包装脚本，让它自动处理 musl 头文件
            # 添加 gnutls 头文件路径，解决交叉编译问题
            # 先创建 posix_memalign_fallback.h 文件，供 configure 使用
            echo "Creating posix_memalign_fallback.h for configure phase"
            cat > posix_memalign_fallback.h << 'EOF'
#ifndef POSIX_MEMALIGN_FALLBACK_H
#define POSIX_MEMALIGN_FALLBACK_H

#include <stdlib.h>
#include <errno.h>
#include <stdint.h>

// Fallback implementation of posix_memalign for HarmonyOS musl
static inline int posix_memalign_fallback(void **memptr, size_t alignment, size_t size) {
    if (alignment < sizeof(void*) || (alignment & (alignment - 1)) != 0) {
        return EINVAL;
    }
    
    // Use aligned_alloc if available, otherwise use malloc + manual alignment
    #ifdef __GLIBC__
    *memptr = aligned_alloc(alignment, size);
    return *memptr ? 0 : ENOMEM;
    #else
    // Fallback: allocate extra space and align manually
    void *ptr = malloc(size + alignment - 1);
    if (!ptr) return ENOMEM;
    
    uintptr_t addr = (uintptr_t)ptr;
    uintptr_t aligned = (addr + alignment - 1) & ~(alignment - 1);
    *memptr = (void*)aligned;
    return 0;
    #endif
}

// Override posix_memalign if not available
#ifndef CONFIG_POSIX_MEMALIGN
#define posix_memalign posix_memalign_fallback
#endif

#endif
EOF

            export CFLAGS="-march=armv8-a -I/usr/include/gnutls -DCONFIG_POSIX_MEMALIGN=1 -include posix_memalign_fallback.h"
            export CXXFLAGS="-march=armv8-a -I/usr/include/gnutls -DCONFIG_POSIX_MEMALIGN=1 -include posix_memalign_fallback.h"
            export LDFLAGS="-L${SYSROOT}/usr/lib -L/usr/lib/x86_64-linux-gnu"
        
        # 确保环境变量正确设置
        export CC="$CC"
        export CXX="$CXX"
        export PATH="$(dirname "$CC"):$PATH"
        
        echo "Final environment before configure:"
        echo "CC: $CC"
        echo "CXX: $CXX"
        echo "PATH: $PATH"
        
        # 测试编译器是否能正常工作
        echo "Testing compiler with simple test:"
        echo 'int main() { return 0; }' > test_cc.c
        if "$CC" -o test_cc test_cc.c 2>&1; then
            echo "✅ CC test compilation successful"
        else
            echo "❌ CC test compilation failed"
            echo "CC output:"
            "$CC" -o test_cc test_cc.c 2>&1 || true
        fi
        rm -f test_cc.c test_cc
        
        # 启用 configure 的详细日志
        export CONFIGURE_DEBUG=1
        
            # 运行 configure 并捕获退出码
            if ! ../configure \
              --target-list=aarch64-softmmu \
              --cc="$CC" \
              --cxx="$CXX" \
              --host-cc="/usr/bin/cc" \
              --cross-prefix="" \
              --extra-cflags="-march=armv8-a -I/usr/include/gnutls -DCONFIG_POSIX_MEMALIGN=1 -include posix_memalign_fallback.h" \
              --extra-cxxflags="-march=armv8-a -I/usr/include/gnutls -DCONFIG_POSIX_MEMALIGN=1 -include posix_memalign_fallback.h" \
              --extra-ldflags="-L${SYSROOT}/usr/lib -L/usr/lib/x86_64-linux-gnu" \
              -Db_staticpic=true \
              -Ddefault_library=static \
              -Dtools=disabled \
              --enable-tcg \
              --disable-kvm \
              --disable-xen \
              --disable-werror \
              --enable-vnc \
              --enable-slirp \
              --enable-curl \
              --enable-fdt \
              --enable-guest-agent \
              --enable-vhost-user \
              --enable-vhost-net \
              --disable-keyring \
              --enable-tpm \
              --disable-gtk \
              --disable-sdl \
              --disable-vte \
              --disable-curses \
              --disable-brlapi \
              --disable-spice \
              --disable-usb-redir \
              --disable-lzo \
              --disable-snappy \
              --disable-bzip2 \
              --disable-lzfse \
              --disable-zstd \
              --disable-libssh \
              --disable-nettle \
              --disable-gcrypt \
              --enable-gnutls; then
                echo "❌ Configure failed, showing detailed logs:"
                echo "=== config.log content ==="
                if [ -f "config.log" ]; then
                    cat config.log
                else
                    echo "config.log not found"
                fi
                echo "=== End of config.log ==="
                exit 1
            fi
            
            echo "✅ Configure completed!"
        
        echo "=== Fixing posix_memalign detection ==="
        # 华为 SDK 有 posix_memalign 声明但没有实现，我们需要强制启用
        echo "Force enabling CONFIG_POSIX_MEMALIGN for HarmonyOS musl compatibility"
        
        # posix_memalign_fallback.h 已经在 configure 之前创建了
        
        # 查找并修复所有可能的配置文件
        for config_file in "config.h" "config-host.h" "config-target.h"; do
            if [ -f "$config_file" ]; then
                echo "Processing $config_file"
                # 移除任何现有的 CONFIG_POSIX_MEMALIGN 定义
                sed -i '/CONFIG_POSIX_MEMALIGN/d' "$config_file"
                # 添加正确的定义
                echo "#define CONFIG_POSIX_MEMALIGN 1" >> "$config_file"
                echo "✓ Added CONFIG_POSIX_MEMALIGN to $config_file"
            fi
        done
        
        # 如果没有任何配置文件，创建一个
        if [ ! -f "config.h" ] && [ ! -f "config-host.h" ]; then
            echo "Creating config.h with CONFIG_POSIX_MEMALIGN"
            echo "#define CONFIG_POSIX_MEMALIGN 1" > config.h
        fi
        
        # 验证修复结果
        echo "Verifying CONFIG_POSIX_MEMALIGN definition:"
        grep -r "CONFIG_POSIX_MEMALIGN" . || echo "No CONFIG_POSIX_MEMALIGN found"
        
        echo "=== Building QEMU ==="
        # 设置正确的链接器环境变量，使用OHOS NDK的工具
        export LD="$CC"
        export AR="$(dirname "$CC")/llvm-ar"
        export RANLIB="$(dirname "$CC")/llvm-ranlib"
        export STRIP="$(dirname "$CC")/llvm-strip"
        
        # 如果找不到llvm工具，使用系统工具
        [ ! -f "$AR" ] && export AR="aarch64-linux-gnu-ar"
        [ ! -f "$RANLIB" ] && export RANLIB="aarch64-linux-gnu-ranlib"
        [ ! -f "$STRIP" ] && export STRIP="aarch64-linux-gnu-strip"
        
        echo "Using tools:"
        echo "LD: $LD"
        echo "AR: $AR"
        echo "RANLIB: $RANLIB"
        echo "STRIP: $STRIP"
        
        make -j$(nproc)
        
        echo "✅ QEMU build completed!"
        
        echo "=== Checking build results ==="
        ls -la qemu-system-aarch64 || echo "Main binary not found"
        find . -name "*.so" -o -name "*.a" | head -10
        
        echo "=== Creating libqemu_full.so ==="
        # 创建 libqemu_full.so 用于鸿蒙 App
        if [ -f "qemu-system-aarch64" ]; then
          echo "Creating libqemu_full.so from qemu-system-aarch64..."
          cp qemu-system-aarch64 libqemu_full.so
          echo "✓ libqemu_full.so created successfully"
          ls -la libqemu_full.so
        else
          echo "✗ qemu-system-aarch64 not found, cannot create libqemu_full.so"
        fi

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: qemu-harmonyos-build
        path: |
          third_party/qemu/build/qemu-system-aarch64
          third_party/qemu/build/libqemu_full.so
          third_party/qemu/build/*.so
          third_party/qemu/build/*.a
        retention-days: 7
