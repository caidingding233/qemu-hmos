name: Build QEMU for HarmonyOS (Robust)

on:
  workflow_dispatch:
  push:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-24.04
    
    steps:
    - name: 下下来
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: 然后安装最小的依赖 (仅主机工具)
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential curl wget unzip python3 \
                                pkg-config git ca-certificates \
                                libglib2.0-dev libpixman-1-dev \
                                libzstd-dev zstd

    - name: 再呢就是设置 Python (用于 Meson/Ninja)
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        cache: 'pip'

    - name: 下一步下 Meson>=1.6 & Ninja, 并锁定 PATH
      run: |
        python -m pip install --upgrade --user 'meson>=1.6.0' 'ninja>=1.11'
        echo "$HOME/.local/bin" >> $GITHUB_PATH
        MESON_BIN="$(python -c 'import shutil;print(shutil.which("meson"))')"
        NINJA_BIN="$(python -c 'import shutil;print(shutil.which("ninja"))')"
        echo "MESON=$MESON_BIN" >> $GITHUB_ENV
        echo "NINJA=$NINJA_BIN" >> $GITHUB_ENV
        echo "Using MESON=$MESON_BIN"
        echo "Using NINJA=$NINJA_BIN"
        "$MESON_BIN" --version
        "$NINJA_BIN" --version
        # Hard guard: fail if < 1.5
        if ! "$MESON_BIN" --version | awk '{split($1,a,"."); exit !((a[1] > 1) || (a[1]==1 && a[2]>=5));}'; then
          echo "::error::Meson too old"; exit 1; fi
        type -a meson || true

    - name: 再就是下鸿蒙的 NDK (linux版)
      run: |
        set -e
        urls=(
          "https://repo.huaweicloud.com/openharmony/os/5.1.0-Release/ohos-sdk-windows_linux-public.tar.gz"
          "https://repo.huaweicloud.com/openharmony/os/5.0.0-Release/ohos-sdk-windows_linux-public.tar.gz"
          "https://repo.huaweicloud.com/openharmony/os/4.1.0-Release/ohos-sdk-windows_linux-public.tar.gz"
        )
        for u in "${urls[@]}"; do
          echo "Try $u"
          if curl -L --retry 3 -o ohos-sdk.tar.gz "$u"; then
            break
          fi
        done
        tar -xzf ohos-sdk.tar.gz
        rm -f ohos-sdk.tar.gz
        # 仅保留 linux 目录
        rm -rf ohos-sdk/ohos ohos-sdk/windows || true
        ls -la ohos-sdk/linux

    - name: 现在来找找到 native 工具链 (clang & sysroot)
      id: ndk
      run: |
        set -e
        cd ohos-sdk/linux
        # 找 native 包
        zip=$(find . -type f -name "*native*linux*x64*.zip" -o -name "*native*linux*.zip" | head -1)
        [ -n "$zip" ] || { echo "No native SDK zip found"; exit 1; }
        unzip -q "$zip"
        rm -f "$zip"

        native_dir=$(find . -maxdepth 1 -type d -name "native-*" -o -name "*native*" | head -1)
        [ -n "$native_dir" ] || { echo "No native dir"; exit 1; }

        llvm_bin="$PWD/$native_dir/llvm/bin"
        sysroot="$PWD/$native_dir/sysroot"

        # 优先使用带 triple 的编译器
        if [ -x "$llvm_bin/aarch64-unknown-linux-ohos-clang" ]; then
          cc="$llvm_bin/aarch64-unknown-linux-ohos-clang"
          cxx="$llvm_bin/aarch64-unknown-linux-ohos-clang++"
        else
          cc="$llvm_bin/clang"
          cxx="$llvm_bin/clang++"
        fi

        echo "OHOS_NDK_HOME=$PWD/$native_dir" >> $GITHUB_ENV
        echo "SYSROOT=$sysroot" >> $GITHUB_ENV
        echo "CC=$cc" >> $GITHUB_ENV
        echo "CXX=$cxx" >> $GITHUB_ENV
        echo "AR=$llvm_bin/llvm-ar" >> $GITHUB_ENV
        echo "RANLIB=$llvm_bin/llvm-ranlib" >> $GITHUB_ENV
        echo "STRIP=$llvm_bin/llvm-strip" >> $GITHUB_ENV

        echo "ndk_dir=$native_dir" >> $GITHUB_OUTPUT

    - name: 在准备 Meson 要用的交叉编译文件(aarch64-ohos.ini)
      run: |
        set -e
        mkdir -p cross
        cat > cross/aarch64-ohos.ini <<EOF
        [binaries]
        c = '${CC}'
        cpp = '${CXX}'
        ar = '${AR}'
        strip = '${STRIP}'
        pkgconfig = 'pkg-config'
        ld = '${CC}'

        [host_machine]
        system = 'linux'
        cpu_family = 'aarch64'
        cpu = 'armv8'
        endian = 'little'

        [built-in options]
        c_args = ['--sysroot=${SYSROOT}','-fPIC','-O2','-pipe','-fvisibility=hidden','-nostdinc','-I${SYSROOT}/usr/include','-I/usr/include/glib-2.0','-I/usr/lib/x86_64-linux-gnu/glib-2.0/include']
        cpp_args = ['--sysroot=${SYSROOT}','-fPIC','-O2','-pipe','-fvisibility=hidden','-nostdinc','-I${SYSROOT}/usr/include','-I/usr/include/glib-2.0','-I/usr/lib/x86_64-linux-gnu/glib-2.0/include']
        c_link_args = ['--sysroot=${SYSROOT}']
        cpp_link_args = ['--sysroot=${SYSROOT}']
        EOF
        echo "Cross file written to: $GITHUB_WORKSPACE/cross/aarch64-ohos.ini"
        ls -la cross
        echo "Preview:"
        sed -n '1,80p' cross/aarch64-ohos.ini

    - name: 再就是提供子项目 (pcre2/libffi 通过 wraps包，glib/pixman用系统的)
      run: |
        set -e
        cd third_party/qemu
        mkdir -p subprojects
        "$MESON" wrap install pcre2
        "$MESON" wrap install libffi
        ls -la subprojects

    - name: 最后就是开始构建QEMU(ARM + X86 多目标构建)
      run: |
        set -e
        echo "MESON is $MESON"
        echo "NINJA is $NINJA"
        if [ ! -x "$MESON" ]; then
          echo "::error::MESON not found or not executable at $MESON"
          which meson || true
          ls -la "$HOME/.local/bin" || true
          exit 1
        fi
        # Export pkg-config：只使用 OHOS sysroot，避免主机系统头文件污染
        export PKG_CONFIG_DIR=
        export PKG_CONFIG_PATH="${SYSROOT}/usr/lib/pkgconfig:${SYSROOT}/usr/share/pkgconfig:${SYSROOT}/lib/pkgconfig"
        echo "PKG_CONFIG_PATH=${PKG_CONFIG_PATH}"
        CROSS_FILE="$GITHUB_WORKSPACE/cross/aarch64-ohos.ini"
        echo "Using CROSS_FILE=$CROSS_FILE"
        if [ ! -f "$CROSS_FILE" ]; then
          echo "::error::Cross file not found at $CROSS_FILE"
          ls -la "$GITHUB_WORKSPACE" || true
          ls -la "$GITHUB_WORKSPACE/cross" || true
          exit 1
        fi
        cd third_party/qemu
        rm -rf build && mkdir build && cd build

        # Detect whether this QEMU fork exposes 'target_list' in meson_options.txt
        TLIST_ARG=""
        if [ -f ../meson_options.txt ] && grep -q "option('target_list'" ../meson_options.txt; then
          TLIST_ARG="-Dtarget_list=aarch64-softmmu,x86_64-softmmu,i386-softmmu"
          echo "Detected target_list option; will pass: ${TLIST_ARG}"
        else
          echo "This QEMU does not define 'target_list'; building project defaults."
        fi

        # 🔧 修复 slirp 测试程序的架构冲突：禁用测试程序构建
        echo "=== 修补 slirp 子项目，禁用测试程序 ==="
        if [ -f "../subprojects/slirp/meson.build" ]; then
          # 备份原始文件
          cp ../subprojects/slirp/meson.build ../subprojects/slirp/meson.build.bak
          
          # 注释掉测试程序构建
          sed -i "s/^executable('pingtest'/# executable('pingtest'/" ../subprojects/slirp/meson.build || true
          sed -i "s/^test('pingtest'/# test('pingtest'/" ../subprojects/slirp/meson.build || true
          
          echo "✅ slirp 测试程序已禁用"
        else
          echo "⚠️  slirp meson.build 未找到，跳过修补"
        fi

        # 鸿蒙版 UTM 多目标构建：使用 configure 脚本（它会调用 meson）
        ../configure \
          --cross-prefix="" \
          --cc="${CC}" \
          --cxx="${CXX}" \
          --host-cc="/usr/bin/cc" \
          --target-list=aarch64-softmmu,x86_64-softmmu,i386-softmmu \
          --extra-cflags="--sysroot=${SYSROOT} -fPIC -march=armv8-a -Wno-error=typedef-redefinition -Wno-error=macro-redefined" \
          --extra-ldflags="--sysroot=${SYSROOT}" \
          --disable-gnutls \
          --disable-gtk --disable-sdl --disable-curses --disable-vte \
          --disable-brlapi --disable-spice --disable-libssh \
          --disable-nettle --disable-gcrypt \
          --enable-tcg \
          --enable-slirp \
          --enable-vnc \
          -Dwrap_mode=forcefallback \
          -Ddefault_library=static \
          -Db_staticpic=true \
          -Dvhost_user=disabled \
          -Dvhost_user_blk_server=disabled \
          -Dlibvduse=disabled \
          -Dvduse_blk_export=disabled \
          -Dvhost_net=disabled \
          -Dvhost_kernel=disabled \
          -Dkeyring=disabled \
          -Dzstd=disabled \
          -Dguest_agent=disabled \
          -Dtools=disabled

        # 构建所有目标
        "$NINJA" -v -j"$(nproc)"

        echo "=== 构建产物检查 ==="
        for bin in qemu-system-aarch64 qemu-system-x86_64 qemu-system-i386; do
          if [ -f "$bin" ]; then
            ls -lh "$bin"
            file "$bin" || true
          else
            echo "Note: $bin not built in this configuration."
          fi
        done
        
        # 产物：优先使用 aarch64，如不存在则挑选已生成的第一个系统仿真器
        OUT_SO=""
        for cand in qemu-system-aarch64 qemu-system-x86_64 qemu-system-i386; do
          if [ -f "$cand" ]; then OUT_SO="$cand"; break; fi
        done
        if [ -n "$OUT_SO" ]; then
          cp "$OUT_SO" libqemu_full.so
          echo "=== 鸿蒙版 UTM 产物 ==="
          ls -lh libqemu_full.so
          file libqemu_full.so || true
        else
          echo "::warning::No qemu-system-* binaries were produced; please inspect meson-logs/meson-log.txt."
        fi

    - name: OK啊上传产物
      uses: actions/upload-artifact@v4
      with:
        name: qemu-hmos-utm-multiarch
        path: |
          third_party/qemu/build/qemu-system-aarch64
          third_party/qemu/build/qemu-system-x86_64
          third_party/qemu/build/qemu-system-i386
          third_party/qemu/build/libqemu_full.so
        if-no-files-found: ignore