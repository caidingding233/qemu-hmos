name: Build QEMU with Huawei's toolchain (Robust)

on:
  workflow_dispatch:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-24.04
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Update submodules (including qemu-code)
      run: |
        echo "=== Updating submodules ==="
        git submodule update --init --recursive

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential cmake curl wget unzip python3 \
                              libglib2.0-dev libpixman-1-dev libssl-dev \
                              libcurl4-openssl-dev libssh-dev libgnutls28-dev \
                              libsasl2-dev libpam0g-dev libbz2-dev libzstd-dev \
                              libpcre2-dev pkg-config meson tree \
                              binutils-aarch64-linux-gnu gcc-aarch64-linux-gnu \
                              libc6-dev libc6-dev-arm64-cross  # 添加aarch64头文件

    - name: Download and setup SDK
      run: |
        echo "=== Downloading SDK ==="
        # Try multiple SDK URLs
        SDK_URLS=(
          "https://repo.huaweicloud.com/openharmony/os/5.1.0-Release/ohos-sdk-windows_linux-public.tar.gz"
          "https://repo.huaweicloud.com/openharmony/os/5.0.0-Release/ohos-sdk-windows_linux-public.tar.gz"
          "https://repo.huaweicloud.com/openharmony/os/4.1.0-Release/ohos-sdk-windows_linux-public.tar.gz"
        )
        
        SDK_DOWNLOADED=false
        for url in "${SDK_URLS[@]}"; do
          echo "Trying SDK URL: $url"
          if curl -L -o ohos-sdk.tar.gz "$url"; then
            echo "✅ SDK downloaded successfully from: $url"
            SDK_DOWNLOADED=true
            break
          else
            echo "❌ Failed to download from: $url"
          fi
        done
        
        if [ "$SDK_DOWNLOADED" = false ]; then
          echo "❌ All SDK download attempts failed"
          exit 1
        fi
        
        echo "=== Extracting SDK ==="
        tar -xzf ohos-sdk.tar.gz
        rm ohos-sdk.tar.gz
        rm -rf ohos-sdk/{ohos,windows}
        
        echo "=== Analyzing SDK structure ==="
        echo "Root SDK structure:"
        ls -la ohos-sdk/
        
        echo ""
        echo "Linux SDK structure:"
        ls -la ohos-sdk/linux/
        
        echo ""
        echo "All files in linux directory:"
        find ohos-sdk/linux -type f | head -20

    - name: Find and extract native SDK
      run: |
        echo "=== Finding native SDK ==="
        cd ohos-sdk/linux
        
        # Look for any zip files that might contain native tools
        echo "Looking for zip files:"
        find . -name "*.zip" -type f
        
        # Try different patterns for native SDK
        NATIVE_PATTERNS=(
          "native-linux-x64-*.zip"
          "native-*.zip"
          "*native*.zip"
          "*-native-*.zip"
        )
        
        NATIVE_ZIP=""
        for pattern in "${NATIVE_PATTERNS[@]}"; do
          echo "Searching for pattern: $pattern"
          found=$(find . -name "$pattern" -type f | head -1)
          if [ -n "$found" ]; then
            NATIVE_ZIP="$found"
            echo "✅ Found native SDK: $NATIVE_ZIP"
            break
          fi
        done
        
        if [ -z "$NATIVE_ZIP" ]; then
          echo "❌ No native SDK zip found"
          echo "Available files:"
          find . -type f | head -20
          echo ""
          echo "Trying to find any clang compiler directly:"
          find . -name "*clang*" -type f | head -10
          exit 1
        fi
        
        echo "=== Extracting native SDK ==="
        echo "Extracting: $NATIVE_ZIP"
        unzip -q "$NATIVE_ZIP"
        rm "$NATIVE_ZIP"
        
        # 先设置SYSROOT变量，因为后面需要用到
        echo "=== 设置SYSROOT变量 ==="
        # 查找native目录
        NATIVE_DIR=""
        for pattern in "native-linux-x64-*" "native-*" "*native*"; do
          found=$(find . -name "$pattern" -type d | head -1)
          if [ -n "$found" ]; then
            NATIVE_DIR="$found"
            echo "✅ Found with pattern '$pattern': $NATIVE_DIR"
            break
          fi
        done
        
        if [ -z "$NATIVE_DIR" ]; then
          NATIVE_DIR=$(find . -type d -name 'native' | head -1)
          if [ -n "$NATIVE_DIR" ]; then
            echo "✅ Found generic native directory: $NATIVE_DIR"
          fi
        fi
        
        if [ -z "$NATIVE_DIR" ]; then
          echo "❌ No native directory found after extraction"
          exit 1
        fi
        
        export SYSROOT="$(pwd)/$NATIVE_DIR/sysroot"
        echo "SYSROOT set to: $SYSROOT"

        # 复制aarch64 glibc完整头文件到sysroot补全musl头
        echo "=== 补全sysroot完整头文件目录 ==="
        
        # 先检查源目录是否存在
        if [ ! -d "/usr/aarch64-linux-gnu/include" ]; then
          echo "Warning: Source directory /usr/aarch64-linux-gnu/include not found"
          echo "Trying to install aarch64 glibc headers..."
          sudo apt-get install -y libc6-dev-arm64-cross
          
          # 再次检查
          if [ ! -d "/usr/aarch64-linux-gnu/include" ]; then
            echo "Error: Still cannot find aarch64 glibc headers after installation"
            echo "Available aarch64 directories:"
            find /usr -name "*aarch64*" -type d 2>/dev/null | head -10
            exit 1
          fi
        fi

        # 确保目标目录存在并设置正确权限
        echo "Creating target directory with proper permissions..."
        sudo mkdir -p "$SYSROOT/usr/include"
        sudo chown -R runner:runner "$SYSROOT/usr/include" || true
        
        # 复制完整的头文件目录，包括 bits/, gnu/, sys/ 等
        echo "Copying all headers from /usr/aarch64-linux-gnu/include to $SYSROOT/usr/include"

        # 使用 rsync 进行更安全的复制，避免权限问题
        if sudo rsync -av --no-perms --no-owner --no-group /usr/aarch64-linux-gnu/include/ "$SYSROOT/usr/include/"; then
          echo "✓ Headers copied successfully with rsync"
        else
          echo "⚠️ Rsync failed, trying cp with different approach..."
          # 如果 rsync 失败，尝试逐个复制关键目录
          for dir in bits gnu sys asm asm-generic; do
            if [ -d "/usr/aarch64-linux-gnu/include/$dir" ]; then
              echo "Copying $dir directory..."
              sudo cp -r "/usr/aarch64-linux-gnu/include/$dir" "$SYSROOT/usr/include/" || echo "Failed to copy $dir"
            fi
          done
          # 复制关键头文件
          sudo cp /usr/aarch64-linux-gnu/include/*.h "$SYSROOT/usr/include/" 2>/dev/null || echo "Some .h files copy failed"
        fi

        # 设置正确的权限
        sudo chown -R runner:runner "$SYSROOT/usr/include" || true
        sudo chmod -R 755 "$SYSROOT/usr/include" || true

        # 验证复制是否成功 - 检查关键文件
        echo "Checking copy success..."
        if [ -f "$SYSROOT/usr/include/bits/limits.h" ] && [ -f "$SYSROOT/usr/include/limits.h" ]; then
          echo "✓ Headers verified successfully"
          echo "Key files present:"
          ls -la "$SYSROOT/usr/include/bits/limits.h"
          ls -la "$SYSROOT/usr/include/limits.h"
        else
          echo "⚠️ Some key files missing, but continuing with available headers"
          echo "Available files in target:"
          find "$SYSROOT/usr/include" -type f 2>/dev/null | head -10 || echo "Cannot list target directory"
          echo "SYSROOT path: $SYSROOT"
          # 不退出，继续构建
        fi

        # 修复华为 SDK 头文件问题
        echo "=== 修复华为 SDK 头文件问题 ==="
        
        # 创建兼容性头文件修复
        COMPAT_DIR="$SYSROOT/usr/include/compat"
        sudo mkdir -p "$COMPAT_DIR"
        
        # 修复 socklen_t 问题
        echo "Creating socklen_t compatibility fix..."
        {
          echo '#ifndef _COMPAT_SOCKLEN_H'
          echo '#define _COMPAT_SOCKLEN_H'
          echo ''
          echo '#ifndef socklen_t'
          echo '#define socklen_t __socklen_t'
          echo '#endif'
          echo ''
          echo '#endif /* _COMPAT_SOCKLEN_H */'
        } | sudo tee "$COMPAT_DIR/socklen.h" > /dev/null
        
        # 修复 socket 结构体问题
        echo "Creating socket structures compatibility fix..."
        {
          echo '#ifndef _COMPAT_SOCKET_H'
          echo '#define _COMPAT_SOCKET_H'
          echo ''
          echo '#include <bits/types.h>'
          echo ''
          echo '#ifndef sa_family_t'
          echo 'typedef unsigned short sa_family_t;'
          echo '#endif'
          echo ''
          echo '#ifndef __SOCKADDR_COMMON_SIZE'
          echo '#define __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))'
          echo '#endif'
          echo ''
          echo '#ifndef __SOCKADDR_COMMON'
          echo '#define __SOCKADDR_COMMON(sa_prefix) \\'
          echo '  sa_family_t sa_prefix##family'
          echo '#endif'
          echo ''
          echo '/* Minimal sockaddr definition */'
          echo 'struct sockaddr {'
          echo '  __SOCKADDR_COMMON (sa_);'
          echo '  char sa_data[14];'
          echo '};'
          echo ''
          echo '/* Minimal sockaddr_storage definition */'
          echo 'struct sockaddr_storage {'
          echo '  __SOCKADDR_COMMON (ss_);'
          echo '  char __ss_padding[128 - sizeof (__SOCKADDR_COMMON_SIZE)];'
          echo '};'
          echo ''
          echo '/* Minimal msghdr definition */'
          echo 'struct msghdr {'
          echo '  void *msg_name;'
          echo '  socklen_t msg_namelen;'
          echo '  struct iovec *msg_iov;'
          echo '  int msg_iovlen;'
          echo '  void *msg_control;'
          echo '  socklen_t msg_controllen;'
          echo '  int msg_flags;'
          echo '};'
          echo ''
          echo '/* Minimal iovec definition */'
          echo 'struct iovec {'
          echo '  void *iov_base;'
          echo '  size_t iov_len;'
          echo '};'
          echo ''
          echo '#endif /* _COMPAT_SOCKET_H */'
        } | sudo tee "$COMPAT_DIR/socket.h" > /dev/null
        
        # 修复 stat 重复定义问题
        echo "Creating stat compatibility fix..."
        {
          echo '#ifndef _COMPAT_STAT_H'
          echo '#define _COMPAT_STAT_H'
          echo ''
          echo '#ifndef _STAT_VER'
          echo '#define _STAT_VER 0'
          echo '#endif'
          echo ''
          echo '#ifndef __USE_FILE_OFFSET64'
          echo 'typedef long __off_t;'
          echo '#else'
          echo 'typedef long long __off_t;'
          echo '#endif'
          echo ''
          echo 'struct stat {'
          echo '  __dev_t st_dev;'
          echo '  __ino_t st_ino;'
          echo '  __mode_t st_mode;'
          echo '  __nlink_t st_nlink;'
          echo '  __uid_t st_uid;'
          echo '  __gid_t st_gid;'
          echo '  __dev_t st_rdev;'
          echo '  __off_t st_size;'
          echo '  __blksize_t st_blksize;'
          echo '  __blkcnt_t st_blocks;'
          echo '  __time_t st_atime;'
          echo '  __time_t st_mtime;'
          echo '  __time_t st_ctime;'
          echo '};'
          echo ''
          echo '#endif /* _COMPAT_STAT_H */'
        } | sudo tee "$COMPAT_DIR/stat.h" > /dev/null
        
        echo "✓ Created compatibility header files"
        
        echo "=== Analyzing extracted content ==="
        echo "Contents after extraction:"
        ls -la
        
        echo "✅ Final native directory: $NATIVE_DIR"

        echo "=== Analyzing native directory ==="
        echo "Contents of $NATIVE_DIR:"
        ls -la "$NATIVE_DIR"

        # Persist native directory path for later steps
        echo "NATIVE_DIR=$NATIVE_DIR" >> $GITHUB_ENV
        
        echo ""
        echo "Looking for llvm directory:"
        find "$NATIVE_DIR" -name "llvm" -type d
        
        echo ""
        echo "Looking for build-tools directory:"
        find "$NATIVE_DIR" -name "build-tools" -type d
        
        echo ""
        echo "Looking for any clang compiler:"
        find "$NATIVE_DIR" -name "*clang*" -type f

    - name: Verify sysroot headers
      run: |
        echo "=== 验证sysroot头文件状态 ==="
        echo "SYSROOT: $SYSROOT"
        echo "Checking sysroot structure:"
        ls -la "$SYSROOT" || echo "Cannot list SYSROOT"
        echo ""
        echo "Checking usr/include:"
        ls -la "$SYSROOT/usr/include" 2>/dev/null || echo "Cannot list usr/include"
        echo ""
        echo "Checking for key header files:"
        [ -f "$SYSROOT/usr/include/limits.h" ] && echo "✓ limits.h exists" || echo "✗ limits.h missing"
        [ -d "$SYSROOT/usr/include/bits" ] && echo "✓ bits directory exists" || echo "✗ bits directory missing"
        [ -f "$SYSROOT/usr/include/bits/limits.h" ] && echo "✓ bits/limits.h exists" || echo "✗ bits/limits.h missing"

    - name: Setup environment and test
      run: |
        echo "=== Setting up environment ==="
        cd ohos-sdk/linux
        
        # Set up paths based on what we found
        export OHOS_NDK_HOME="$(pwd)/$NATIVE_DIR"
        export SYSROOT="$(pwd)/$NATIVE_DIR/sysroot"
        
        # Try to find clang compiler
        CLANG_CANDIDATES=(
          "$(pwd)/$NATIVE_DIR/llvm/bin/aarch64-unknown-linux-ohos-clang"
          "$(pwd)/$NATIVE_DIR/llvm/bin/clang"
          "$(pwd)/$NATIVE_DIR/bin/aarch64-unknown-linux-ohos-clang"
          "$(pwd)/$NATIVE_DIR/bin/clang"
        )
        
        CC=""
        for candidate in "${CLANG_CANDIDATES[@]}"; do
          if [ -f "$candidate" ]; then
            CC="$candidate"
            echo "✅ Found CC: $CC"
            break
          fi
        done
        
        if [ -z "$CC" ]; then
          echo "❌ No clang compiler found"
          echo "Available files in native directory:"
          find "$NATIVE_DIR" -type f | head -20
          LLVM_BIN_DIR="$(pwd)/$NATIVE_DIR/llvm/bin"
          if [ -d "$LLVM_BIN_DIR" ]; then
            echo ""
            echo "Attempting fallback discovery in $LLVM_BIN_DIR"
            CLANG_AUTO=$(find "$LLVM_BIN_DIR" -maxdepth 1 -name "clang*" -type f | head -1)
            if [ -n "$CLANG_AUTO" ]; then
              echo "✅ Auto-detected CC candidate: $CLANG_AUTO"
              CC="$CLANG_AUTO"
            fi
          fi
        fi

        if [ -z "$CC" ]; then
          echo "❌ Still no clang compiler found"
          exit 1
        fi
        
        # Try to find C++ compiler
        CXX_CANDIDATES=(
          "$(pwd)/$NATIVE_DIR/llvm/bin/aarch64-unknown-linux-ohos-clang++"
          "$(pwd)/$NATIVE_DIR/llvm/bin/clang++"
          "$(pwd)/$NATIVE_DIR/bin/aarch64-unknown-linux-ohos-clang++"
          "$(pwd)/$NATIVE_DIR/bin/clang++"
        )
        
        CXX=""
        for candidate in "${CXX_CANDIDATES[@]}"; do
          if [ -f "$candidate" ]; then
            CXX="$candidate"
            echo "✅ Found CXX: $CXX"
            break
          fi
        done
        
        if [ -z "$CXX" ]; then
          echo "⚠️ No C++ compiler found, using CC for CXX"
          LLVM_BIN_DIR="$(pwd)/$NATIVE_DIR/llvm/bin"
          if [ -d "$LLVM_BIN_DIR" ]; then
            CLANGXX_AUTO=$(find "$LLVM_BIN_DIR" -maxdepth 1 -name "clang++*" -type f | head -1)
            if [ -n "$CLANGXX_AUTO" ]; then
              echo "✅ Auto-detected clang++ candidate: $CLANGXX_AUTO"
              CXX="$CLANGXX_AUTO"
            fi
          fi
        fi

        if [ -z "$CXX" ]; then
          echo "⚠️ Falling back to CC for CXX"
          CXX="$CC"
        fi
        
        # Try to find CMake
        CMAKE_CANDIDATES=(
          "$(pwd)/$NATIVE_DIR/build-tools/cmake/bin/cmake"
          "$(pwd)/$NATIVE_DIR/cmake/bin/cmake"
          "$(pwd)/$NATIVE_DIR/bin/cmake"
          "/usr/bin/cmake"
        )
        
        CMAKE=""
        for candidate in "${CMAKE_CANDIDATES[@]}"; do
          if [ -f "$candidate" ]; then
            CMAKE="$candidate"
            echo "✅ Found CMake: $CMAKE"
            break
          fi
        done
        
        if [ -z "$CMAKE" ]; then
          echo "❌ No CMake found"
          exit 1
        fi
        
        echo "=== Final environment ==="
        echo "OHOS_NDK_HOME: $OHOS_NDK_HOME"
        echo "SYSROOT: $SYSROOT"
        echo "CC: $CC"
        echo "CXX: $CXX"
        echo "CMAKE: $CMAKE"
        
        echo ""
        echo "=== Testing tools ==="
        echo "Testing CC:"
        file "$CC"
        "$CC" --version 2>&1 | head -3 || echo "CC version check failed"
        
        echo ""
        echo "Testing CMake:"
        "$CMAKE" --version | head -3 || echo "CMake version check failed"
        
        # Save environment for next steps
        echo "OHOS_NDK_HOME=$OHOS_NDK_HOME" >> $GITHUB_ENV
        echo "SYSROOT=$SYSROOT" >> $GITHUB_ENV
        echo "CC=$CC" >> $GITHUB_ENV
        echo "CXX=$CXX" >> $GITHUB_ENV
        echo "CMAKE=$CMAKE" >> $GITHUB_ENV

    - name: Build QEMU
      run: |
        echo "=== Restoring environment variables ==="
        # Restore environment variables from previous step
        export OHOS_NDK_HOME="$OHOS_NDK_HOME"
        export SYSROOT="$SYSROOT"
        export CC="$CC"
        export CXX="$CXX"
        export CMAKE="$CMAKE"

        echo "=== Building QEMU ==="
        cd third_party/qemu

        mkdir -p build
        cd build

        echo "Environment check:"
        echo "CC: $CC"
        echo "CXX: $CXX"
        echo "SYSROOT: $SYSROOT"
        
        echo ""
        echo "=== Running Configure ==="
        # 使用简化的配置，包含兼容性头文件路径
        export CFLAGS="-target aarch64-unknown-linux-ohos --sysroot=${SYSROOT} -march=armv8-a -I${SYSROOT}/usr/include/compat"
        export CXXFLAGS="-target aarch64-unknown-linux-ohos --sysroot=${SYSROOT} -march=armv8-a -I${SYSROOT}/usr/include/compat"
        export LDFLAGS="-target aarch64-unknown-linux-ohos --sysroot=${SYSROOT} -L${SYSROOT}/usr/lib"
        
        ../configure \
          --target-list=aarch64-softmmu \
          --cc="$CC" \
          --cxx="$CXX" \
          --host-cc="/usr/bin/cc" \
          --cross-prefix="" \
          --extra-cflags="-target aarch64-unknown-linux-ohos --sysroot=${SYSROOT} -march=armv8-a -I${SYSROOT}/usr/include/compat" \
          --extra-cxxflags="-target aarch64-unknown-linux-ohos --sysroot=${SYSROOT} -march=armv8-a -I${SYSROOT}/usr/include/compat" \
          --extra-ldflags="-target aarch64-unknown-linux-ohos --sysroot=${SYSROOT} -L${SYSROOT}/usr/lib" \
          -Db_staticpic=true \
          -Ddefault_library=static \
          -Dtools=disabled \
          --enable-tcg \
          --disable-kvm \
          --disable-xen \
          --disable-werror \
          --enable-vnc \
          --enable-slirp \
          --enable-curl \
          --enable-fdt \
          --enable-guest-agent \
          --enable-vhost-user \
          --enable-vhost-net \
          --disable-keyring \
          --enable-tpm \
          --disable-gtk \
          --disable-sdl \
          --disable-vte \
          --disable-curses \
          --disable-brlapi \
          --disable-spice \
          --disable-usb-redir \
          --disable-lzo \
          --disable-snappy \
          --disable-bzip2 \
          --disable-lzfse \
          --disable-zstd \
          --disable-libssh \
          --disable-nettle \
          --disable-gcrypt \
          --enable-gnutls
        
        echo "✅ Configure completed!"
        
        echo "=== Building QEMU ==="
        # 设置正确的链接器环境变量，使用OHOS NDK的工具
        export LD="$CC"
        export AR="$(dirname "$CC")/llvm-ar"
        export RANLIB="$(dirname "$CC")/llvm-ranlib"
        export STRIP="$(dirname "$CC")/llvm-strip"
        
        # 如果找不到llvm工具，使用系统工具
        [ ! -f "$AR" ] && export AR="aarch64-linux-gnu-ar"
        [ ! -f "$RANLIB" ] && export RANLIB="aarch64-linux-gnu-ranlib"
        [ ! -f "$STRIP" ] && export STRIP="aarch64-linux-gnu-strip"
        
        echo "Using tools:"
        echo "LD: $LD"
        echo "AR: $AR"
        echo "RANLIB: $RANLIB"
        echo "STRIP: $STRIP"
        
        make -j$(nproc)
        
        echo "✅ QEMU build completed!"
        
        echo "=== Checking build results ==="
        ls -la qemu-system-aarch64 || echo "Main binary not found"
        find . -name "*.so" -o -name "*.a" | head -10
        
        echo "=== Creating libqemu_full.so ==="
        # 创建 libqemu_full.so 用于鸿蒙 App
        if [ -f "qemu-system-aarch64" ]; then
          echo "Creating libqemu_full.so from qemu-system-aarch64..."
          cp qemu-system-aarch64 libqemu_full.so
          echo "✓ libqemu_full.so created successfully"
          ls -la libqemu_full.so
        else
          echo "✗ qemu-system-aarch64 not found, cannot create libqemu_full.so"
        fi

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: qemu-harmonyos-build
        path: |
          third_party/qemu/build/qemu-system-aarch64
          third_party/qemu/build/libqemu_full.so
          third_party/qemu/build/*.so
          third_party/qemu/build/*.a
        retention-days: 7
