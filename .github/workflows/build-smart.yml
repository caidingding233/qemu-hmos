name: Build QEMU with Huawei's toolchain (Smart)

on:
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-24.04
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential cmake curl wget unzip python3 \
                              libglib2.0-dev libpixman-1-dev libssl-dev \
                              libcurl4-openssl-dev libssh-dev libgnutls28-dev \
                              libsasl2-dev libpam0g-dev libbz2-dev libzstd-dev \
                              libpcre2-dev pkg-config meson tree

    - name: Download and setup SDK
      run: |
        echo "=== Downloading SDK ==="
        curl -OL https://repo.huaweicloud.com/openharmony/os/5.1.0-Release/ohos-sdk-windows_linux-public.tar.gz
        
        echo "=== Extracting SDK ==="
        tar -xzf ohos-sdk-windows_linux-public.tar.gz
        rm ohos-sdk-windows_linux-public.tar.gz
        rm -rf ohos-sdk/{ohos,windows}
        
        echo "=== Processing SDK ==="
        cd ohos-sdk/linux
        
        echo "=== Finding native SDK zip ==="
        NATIVE_ZIP=$(find . -name "native-linux-x64-*.zip" | head -1)
        if [ -z "$NATIVE_ZIP" ]; then
          echo "❌ Could not find native-linux-x64-*.zip"
          echo "Available files:"
          ls -la
          exit 1
        fi
        
        echo "✅ Found native SDK: $NATIVE_ZIP"
        
        echo "=== Extracting native SDK ==="
        unzip -q "$NATIVE_ZIP"
        rm "$NATIVE_ZIP"
        
        echo "=== Analyzing extracted content ==="
        echo "Contents after extraction:"
        ls -la
        
        # Find native directory
        NATIVE_DIR=$(find . -type d -name 'native*' | head -1)
        if [ -z "$NATIVE_DIR" ]; then
          echo "❌ No native directory found"
          echo "Available directories:"
          find . -type d
          exit 1
        fi
        
        echo "✅ Found native directory: $NATIVE_DIR"
        
        echo "=== Analyzing native directory structure ==="
        echo "Contents of $NATIVE_DIR:"
        ls -la "$NATIVE_DIR"
        
        echo ""
        echo "=== Looking for llvm directory ==="
        find "$NATIVE_DIR" -name "llvm" -type d
        
        echo ""
        echo "=== Looking for build-tools directory ==="
        find "$NATIVE_DIR" -name "build-tools" -type d
        
        echo ""
        echo "=== Looking for any executable files ==="
        find "$NATIVE_DIR" -type f -executable | head -20
        
        echo ""
        echo "=== Looking for any clang files ==="
        find "$NATIVE_DIR" -name "*clang*" -type f
        
        echo ""
        echo "=== Looking for any gcc files ==="
        find "$NATIVE_DIR" -name "*gcc*" -type f
        
        echo ""
        echo "=== Looking for any cc files ==="
        find "$NATIVE_DIR" -name "*cc*" -type f

    - name: Smart compiler detection
      run: |
        cd ohos-sdk/linux
        
        # Re-find native directory
        NATIVE_DIR=$(find . -type d -name 'native*' | head -1)
        echo "Using native directory: $NATIVE_DIR"
        
        echo "=== Smart compiler detection ==="
        
        # Set up base paths
        export OHOS_NDK_HOME="$(pwd)/$NATIVE_DIR"
        export SYSROOT="$(pwd)/$NATIVE_DIR/sysroot"
        
        # Smart clang detection
        echo "=== Finding clang compiler ==="
        CLANG_CANDIDATES=(
          "$NATIVE_DIR/llvm/bin/aarch64-unknown-linux-ohos-clang"
          "$NATIVE_DIR/llvm/bin/clang"
          "$NATIVE_DIR/bin/aarch64-unknown-linux-ohos-clang"
          "$NATIVE_DIR/bin/clang"
        )
        
        # Add any clang files found
        while IFS= read -r clang_file; do
          if [ -f "$clang_file" ] && [ -x "$clang_file" ]; then
            CLANG_CANDIDATES+=("$clang_file")
          fi
        done < <(find "$NATIVE_DIR" -name "*clang*" -type f)
        
        CC=""
        for candidate in "${CLANG_CANDIDATES[@]}"; do
          if [ -f "$candidate" ] && [ -x "$candidate" ]; then
            echo "Testing candidate: $candidate"
            if "$candidate" --version >/dev/null 2>&1; then
              CC="$candidate"
              echo "✅ Found working CC: $CC"
              break
            else
              echo "❌ Candidate failed version check: $candidate"
            fi
          fi
        done
        
        if [ -z "$CC" ]; then
          echo "❌ No working clang compiler found"
          echo "All clang candidates tested:"
          printf '%s\n' "${CLANG_CANDIDATES[@]}"
          exit 1
        fi
        
        # Smart C++ detection
        echo ""
        echo "=== Finding C++ compiler ==="
        CXX_CANDIDATES=(
          "$NATIVE_DIR/llvm/bin/aarch64-unknown-linux-ohos-clang++"
          "$NATIVE_DIR/llvm/bin/clang++"
          "$NATIVE_DIR/bin/aarch64-unknown-linux-ohos-clang++"
          "$NATIVE_DIR/bin/clang++"
        )
        
        # Add any clang++ files found
        while IFS= read -r cxx_file; do
          if [ -f "$cxx_file" ] && [ -x "$cxx_file" ]; then
            CXX_CANDIDATES+=("$cxx_file")
          fi
        done < <(find "$NATIVE_DIR" -name "*clang++*" -type f)
        
        CXX=""
        for candidate in "${CXX_CANDIDATES[@]}"; do
          if [ -f "$candidate" ] && [ -x "$candidate" ]; then
            echo "Testing candidate: $candidate"
            if "$candidate" --version >/dev/null 2>&1; then
              CXX="$candidate"
              echo "✅ Found working CXX: $CXX"
              break
            else
              echo "❌ Candidate failed version check: $candidate"
            fi
          fi
        done
        
        if [ -z "$CXX" ]; then
          echo "⚠️ No C++ compiler found, using CC for CXX"
          CXX="$CC"
        fi
        
        # Smart CMake detection
        echo ""
        echo "=== Finding CMake ==="
        CMAKE_CANDIDATES=(
          "$NATIVE_DIR/build-tools/cmake/bin/cmake"
          "$NATIVE_DIR/cmake/bin/cmake"
          "$NATIVE_DIR/bin/cmake"
          "/usr/bin/cmake"
        )
        
        # Add any cmake files found
        while IFS= read -r cmake_file; do
          if [ -f "$cmake_file" ] && [ -x "$cmake_file" ]; then
            CMAKE_CANDIDATES+=("$cmake_file")
          fi
        done < <(find "$NATIVE_DIR" -name "*cmake*" -type f)
        
        CMAKE=""
        for candidate in "${CMAKE_CANDIDATES[@]}"; do
          if [ -f "$candidate" ] && [ -x "$candidate" ]; then
            echo "Testing candidate: $candidate"
            if "$candidate" --version >/dev/null 2>&1; then
              CMAKE="$candidate"
              echo "✅ Found working CMake: $CMAKE"
              break
            else
              echo "❌ Candidate failed version check: $candidate"
            fi
          fi
        done
        
        if [ -z "$CMAKE" ]; then
          echo "❌ No working CMake found"
          exit 1
        fi
        
        echo "=== Final environment ==="
        echo "OHOS_NDK_HOME: $OHOS_NDK_HOME"
        echo "SYSROOT: $SYSROOT"
        echo "CC: $CC"
        echo "CXX: $CXX"
        echo "CMAKE: $CMAKE"
        
        # Save environment for next steps
        echo "OHOS_NDK_HOME=$OHOS_NDK_HOME" >> $GITHUB_ENV
        echo "SYSROOT=$SYSROOT" >> $GITHUB_ENV
        echo "CC=$CC" >> $GITHUB_ENV
        echo "CXX=$CXX" >> $GITHUB_ENV
        echo "CMAKE=$CMAKE" >> $GITHUB_ENV

    - name: Build QEMU
      run: |
        echo "=== Building QEMU ==="
        cd third_party/qemu
        
        mkdir -p build
        cd build
        
        echo "Environment check:"
        echo "CC: $CC"
        echo "CXX: $CXX"
        echo "SYSROOT: $SYSROOT"
        
        echo ""
        echo "=== Running Configure ==="
        ../configure \
          --target-list=aarch64-softmmu \
          --cc="$CC" \
          --cxx="$CXX" \
          --host-cc="/usr/bin/cc" \
          --cross-prefix="" \
          --extra-cflags="-target aarch64-unknown-linux-ohos --sysroot=${SYSROOT}" \
          --extra-ldflags="-target aarch64-unknown-linux-ohos --sysroot=${SYSROOT}" \
          -Db_staticpic=true \
          -Db_pie=false \
          -Ddefault_library=static \
          -Dtools=disabled \
          --enable-tcg \
          --disable-kvm \
          --disable-xen \
          --disable-werror \
          --enable-vnc \
          --enable-slirp \
          --enable-curl \
          --enable-fdt \
          --enable-guest-agent \
          --enable-vhost-user \
          --enable-vhost-net \
          --enable-keyring \
          --disable-gtk \
          --disable-sdl \
          --disable-vte \
          --disable-curses \
          --disable-brlapi \
          --disable-spice \
          --disable-usb-redir \
          --disable-lzo \
          --disable-snappy \
          --disable-bzip2 \
          --disable-lzfse \
          --disable-zstd \
          --disable-libssh \
          --disable-nettle \
          --disable-gcrypt
        
        echo "✅ Configure completed!"
        
        echo "=== Building QEMU ==="
        make -j$(nproc)
        
        echo "✅ QEMU build completed!"
        
        echo "=== Checking build results ==="
        ls -la qemu-system-aarch64 || echo "Main binary not found"
        find . -name "*.so" -o -name "*.a" | head -10

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: qemu-harmonyos-smart-build
        path: |
          third_party/qemu/build/qemu-system-aarch64
          third_party/qemu/build/*.so
          third_party/qemu/build/*.a
        retention-days: 7
